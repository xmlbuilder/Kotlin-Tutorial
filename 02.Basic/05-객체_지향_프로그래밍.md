# 🧱 Kotlin으로 배우는 객체 지향 프로그래밍
절차 지향 프로그래밍에서 객체 지향 프로그래밍으로 점진적으로 전환하는 과정을 설명한 문서의 핵심 내용을 정리한 요약입니다.

## 🎯 프로그래밍 패러다임: 절차 지향 vs 객체 지향
### 🔧 절차 지향 프로그래밍
- 실행 순서 중심으로 프로그래밍
- 데이터와 기능이 분리됨
- 모든 로직이 main() 함수에 존재
- 
### 🧱 객체 지향 프로그래밍
- 객체 중심으로 프로그래밍
- 데이터와 기능을 하나의 단위로 묶음
- 유지보수, 확장성, 재사용성 향상

## 🎵 예제: 음악 플레이어 만들기
### 1️⃣ 절차 지향 방식
```kotlin
fun main() {
    var volume = 0
    var isOn = false

    isOn = true
    println("음악 플레이어를 시작합니다")

    volume++
    println("음악 플레이어 볼륨: $volume")

    volume++
    println("음악 플레이어 볼륨: $volume")

    volume--
    println("음악 플레이어 볼륨: $volume")

    println("음악 플레이어 상태 확인")
    if (isOn) println("음악 플레이어 ON, 볼륨: $volume")
    else println("음악 플레이어 OFF")

    isOn = false
    println("음악 플레이어를 종료합니다")
}
```

### 2️⃣ 데이터 묶음 도입
```kotlin
class MusicPlayerData(var volume: Int = 0, var isOn: Boolean = false)

fun main() {
    val player = MusicPlayerData()

    player.isOn = true
    println("음악 플레이어를 시작합니다")

    player.volume++
    println("음악 플레이어 볼륨: ${player.volume}")

    player.volume++
    println("음악 플레이어 볼륨: ${player.volume}")

    player.volume--
    println("음악 플레이어 볼륨: ${player.volume}")

    println("음악 플레이어 상태 확인")
    if (player.isOn) println("음악 플레이어 ON, 볼륨: ${player.volume}")
    else println("음악 플레이어 OFF")

    player.isOn = false
    println("음악 플레이어를 종료합니다")
}
```
### 3️⃣ 기능 분리 (절차 지향 + 메서드)
```kotlin
fun on(player: MusicPlayerData) {
    player.isOn = true
    println("음악 플레이어를 시작합니다")
}

fun off(player: MusicPlayerData) {
    player.isOn = false
    println("음악 플레이어를 종료합니다")
}

fun volumeUp(player: MusicPlayerData) {
    player.volume++
    println("음악 플레이어 볼륨: ${player.volume}")
}

fun volumeDown(player: MusicPlayerData) {
    player.volume--
    println("음악 플레이어 볼륨: ${player.volume}")
}

fun showStatus(player: MusicPlayerData) {
    println("음악 플레이어 상태 확인")
    if (player.isOn) println("음악 플레이어 ON, 볼륨: ${player.volume}")
    else println("음악 플레이어 OFF")
}
```

## ⚠️ 절차 지향의 한계
- 데이터와 기능이 분리되어 유지보수 어려움
- 기능이 객체 외부에 존재 → 응집도 낮음

## ✅ 객체 지향 방식
```kotlin
class MusicPlayer {
    var volume = 0
    var isOn = false

    fun on() {
        isOn = true
        println("음악 플레이어를 시작합니다")
    }

    fun off() {
        isOn = false
        println("음악 플레이어를 종료합니다")
    }

    fun volumeUp() {
        volume++
        println("음악 플레이어 볼륨: $volume")
    }

    fun volumeDown() {
        volume--
        println("음악 플레이어 볼륨: $volume")
    }

    fun showStatus() {
        println("음악 플레이어 상태 확인")
        if (isOn) println("음악 플레이어 ON, 볼륨: $volume")
        else println("음악 플레이어 OFF")
    }
}


fun main() {
    val player = MusicPlayer()
    player.on()
    player.volumeUp()
    player.volumeUp()
    player.volumeDown()
    player.showStatus()
    player.off()
}
```

## 🧭 프로그래밍 패러다임 전환 요약
### 1️⃣ 데이터만 있는 클래스
```kotlin
class ValueData(var value: Int)
```

### 2️⃣ 기능을 포함한 클래스
```kotlin
class ValueObject(var value: Int) {
    fun add() {
        value++
        println("숫자 증가 value=$value")
    }
}
```

## 🧩 문제 예제: 직사각형
### 절차 지향
```kotlin
fun calculateArea(w: Int, h: Int) = w * h
fun calculatePerimeter(w: Int, h: Int) = 2 * (w + h)
fun isSquare(w: Int, h: Int) = w == h
```

### 객체 지향
```kotlin
class Rectangle(var width: Int, var height: Int) {
    fun calculateArea() = width * height
    fun calculatePerimeter() = 2 * (width + height)
    fun isSquare() = width == height
}
```
## 🏦 문제 예제: 은행 계좌
```kotlin
class Account(var balance: Int = 0) {
    fun deposit(amount: Int) {
        balance += amount
    }

    fun withdraw(amount: Int) {
        if (balance >= amount) {
            balance -= amount
        } else {
            println("잔액 부족")
        }
    }
}

fun main() {
    val account = Account()
    account.deposit(10000)
    account.withdraw(9000)
    account.withdraw(2000)
    println("잔고: ${account.balance}")
}
```

## 🎯 객체 지향 핵심 개념
| 개념       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 캡슐화     | 관련된 데이터와 기능을 하나의 클래스에 묶어 외부로부터 숨김              |
| 추상화     | 복잡한 내부 구현은 감추고 필요한 기능만 외부에 제공                      |
| 상속       | 기존 클래스의 기능을 재사용하고 확장 가능 (`open`, `:`, `super`) 사용     |
| 다형성     | 동일한 인터페이스로 다양한 구현을 처리 가능 (`override`, `interface`) 활용 |
| 메시지 전달 | 객체 간 메서드 호출을 통해 상호작용 (`player.volumeUp()`)               |


## ✅ 결론
| 항목             | 절차 지향 방식                         | 객체 지향 방식                             |
|------------------|----------------------------------------|--------------------------------------------|
| 중심 개념        | 실행 순서 중심 ("어떻게")              | 객체 중심 ("무엇을")                       |
| 데이터와 기능    | 분리되어 있음                           | 객체 내부에 함께 포함됨                    |
| 코드 구조        | 함수 중심 (`calculateArea(w, h)`)       | 클래스 중심 (`Rectangle().calculateArea()`) |
| 유지보수성       | 기능 변경 시 여러 위치 수정 필요         | 객체 내부만 수정하면 됨                    |
| 확장성           | 기능 추가 시 구조 변경 어려움            | 메서드 추가로 유연하게 확장 가능           |

---

# function / class method

Kotlin에서의 **함수(function)** 와 **클래스 메서드(method)** 의 차이점과 사용 방식에 대한 정리입니다.  
fun calculateArea(w: Int, h: Int) = w * h 같은 함수와 클래스 내부의 메서드는 목적과 문맥에 따라 다르게 사용.

## 🎯 Kotlin 함수 vs 클래스 메서드
| 항목             | 함수 (Function)                              | 클래스 메서드 (Method)                          |
|------------------|-----------------------------------------------|--------------------------------------------------|
| 정의 위치        | 클래스 외부 (파일 수준)                       | 클래스 내부                                      |
| 호출 방식        | `calculateArea(5, 8)`                         | `rectangle.calculateArea()`                     |
| 내부 상태 접근    | 불가능 (매개변수로 전달해야 함)               | 가능 (`this`로 클래스 속성 접근 가능)            |
| 대표 예시        | `fun add(a: Int, b: Int): Int = a + b`        | `fun volumeUp() { volume++ }`                   |
| 목적             | 독립적인 기능 수행                            | 객체의 상태를 기반으로 동작                      |


## ✅ 예시 비교
## 1️⃣ 일반 함수 (파일 수준)
```kotlin
fun calculateArea(w: Int, h: Int): Int = w * h

fun main() {
    val area = calculateArea(5, 8)
    println("넓이: $area")
}
```

- 독립적인 계산 로직
- 객체 상태와 무관

## 2️⃣ 클래스 메서드
```kotlin
class Rectangle(val width: Int, val height: Int) {
    fun calculateArea(): Int = width * height
}

fun main() {
    val rect = Rectangle(5, 8)
    println("넓이: ${rect.calculateArea()}")
}
```

- 객체의 속성(width, height)을 직접 사용
- 객체 중심 설계에 적합

## 💡 Kotlin의 함수 특징
- fun 키워드로 정의
- 파일 수준 함수는 패키지 단위로 관리 가능
- 클래스 내부 메서드는 객체의 상태를 조작하거나 참조할 수 있음
- 확장 함수(fun String.isEmail(): Boolean)도 가능

## 🧠 정리
| 항목             | 절차 지향 방식                         | 객체 지향 방식                             |
|------------------|----------------------------------------|--------------------------------------------|
| 중심 개념        | 실행 순서 중심 ("어떻게")              | 객체 중심 ("무엇을")                       |
| 기능 정의 위치    | 클래스 외부 함수 (`fun calculateArea`) | 클래스 내부 메서드 (`fun calculateArea()`) |
| 데이터와 기능    | 분리되어 있음                           | 객체 내부에 함께 포함됨                    |
| 상태 접근 방식    | 매개변수로 전달                        | `this`로 직접 접근                         |

---

## 🎯 Kotlin의 표현식 기반 함수란?
- 함수 본문이 단일 표현식일 경우, 중괄호 {} 없이 = 기호로 바로 결과를 반환할 수 있음.
- return 키워드도 생략됩니다.
- 이 방식은 간단한 계산, 변환, 조건 처리에 매우 유용합니다.
###  ✅ 예시
```rust
fun square(x: Int) = x * x
fun isEven(n: Int) = n % 2 == 0
fun greet(name: String) = "Hello, $name!"
```

### 🔍 비교: 표현식 vs 블록 함수
| 항목             | 표현식 기반 함수                              | 블록 기반 함수                                 |
|------------------|-----------------------------------------------|------------------------------------------------|
| 문법 스타일       | `fun add(a: Int, b: Int) = a + b`             | `fun add(a: Int, b: Int) { return a + b }`     |
| 중괄호 사용       | ❌ 없음                                        | ✅ 있음                                          |
| return 키워드     | ❌ 생략 가능                                    | ✅ 명시 필요                                     |
| 함수 본문         | 단일 표현식만 가능                             | 여러 줄 로직 가능                               |
| 가독성            | 간결하고 직관적                                | 복잡한 로직에 적합                              |
| 사용 용도         | 계산, 변환, 조건 등 간단한 기능                | 예외 처리, 반복문, 조건 분기 등 복잡한 기능     |


### 💡 팁
- 표현식 기반 함수는 간결성과 가독성을 높음.
- 하지만 복잡한 로직이나 예외 처리가 필요한 경우에는 블록 기반 함수가 더 적합해요.

---
