# 🧠 Kotlin에서의 중첩 클래스 vs 내부 클래스
## ✅ 정의
- 중첩 클래스 (Nested Class): 클래스 안에 정의된 클래스. 기본적으로 바깥 클래스의 인스턴스와 무관하게 동작 (Java의 static class와 유사)
- 내부 클래스 (Inner Class): inner 키워드를 사용하여 바깥 클래스의 인스턴스에 접근 가능한 클래스
```kotlin
class Outer {


    // 중첩 클래스 (정적 성격)
    class StaticNested {
        // ...
    }


    // 내부 클래스 (바깥 인스턴스 접근 가능)
    inner class Inner {
        // ...
    }


    fun process() {
        val localVar = 0


        // 지역 클래스
        class Local {
            // ...
        }

        val local = Local()


        // 익명 클래스
        val runnable = object : Runnable {
            override fun run() {
                println("익명 클래스 실행")
            }
        }
    }
}
```


## ✅ 중첩 클래스 분류 (Kotlin 기준)
| 클래스 종류        | 설명                                      | 바깥 클래스 인스턴스 접근 여부 |
|--------------------|-------------------------------------------|-------------------------------|
| 중첩 클래스         | 기본 `class`로 선언. 정적(static) 성격     | ❌ 접근 불가                   |
| 내부 클래스         | `inner class`로 선언. 바깥 인스턴스 접근 가능 | ✅ 접근 가능                   |
| 지역 클래스         | 함수 또는 블록 내부에서 선언된 클래스       | ✅ 접근 가능                   |
| 익명 클래스         | 이름 없이 객체 표현식으로 선언된 클래스     | ✅ 접근 가능                   |


## 🔍 Kotlin의 주요 차이점
- Kotlin에는 static 키워드가 없으며, 중첩 클래스는 기본적으로 정적(static)처럼 동작합니다.
- 바깥 클래스의 인스턴스에 접근하려면 반드시 `inner` 키워드를 사용해야 합니다.
- 익명 클래스는 `object : 인터페이스 { ... }` 형태로 표현됩니다.


## ✅ 선언 위치와 변수 대응 (Kotlin 기준)
| 클래스 종류         | 선언 위치               | 대응되는 변수 종류     | 바깥 인스턴스 접근 여부 | Kotlin 키워드/특징         |
|----------------------|--------------------------|--------------------------|--------------------------|-----------------------------|
| 중첩 클래스          | 클래스 본문              | 정적 변수처럼 동작       | ❌ 접근 불가             | 기본 `class` (static 성격)  |
| 내부 클래스          | 클래스 본문              | 인스턴스 변수            | ✅ 접근 가능             | `inner class` 사용          |
| 지역 클래스          | 함수 또는 블록 내부       | 지역 변수                | ✅ 접근 가능             | 함수 내 `class` 선언 가능    |
| 익명 클래스          | 함수 또는 블록 내부       | 지역 변수 (이름 없음)    | ✅ 접근 가능             | `object : 인터페이스 {}`    |

## 🔍 Kotlin의 특징 요약
- Kotlin에는 static 키워드가 없고, 중첩 클래스는 기본적으로 바깥 인스턴스와 무관하게 동작
- 바깥 클래스의 인스턴스에 접근하려면 inner 키워드를 명시해야 함
- 지역 클래스와 익명 클래스는 함수 내부에서 선언되며, 바깥 인스턴스와 지역 변수에 접근 가능


## ✅ 생성 방식
```kotlin
val outer = ShadowingMain()
val inner = outer.Inner() // Kotlin에서는 내부 클래스 생성 시 바깥 인스턴스가 필요
```
- 내부 클래스는 바깥 클래스의 인스턴스에 소속되므로 반드시 바깥 인스턴스가 먼저 생성되어야 함

## 🧪 내부 클래스 활용 – Kotlin 리팩토링 예제
### 🔧 리팩토링 전
```kotlin
class Engine(private val car: Car) {
    fun start() {
        println("충전 레벨 확인: ${car.chargeLevel}")
        println("${car.model}의 엔진을 구동합니다.")
    }
}

class Car(val model: String, val chargeLevel: Int) {
    private val engine = Engine(this)

    fun start() {
        engine.start()
        println("$model 시작 완료")
    }
}
```

### 🔧 리팩토링 후 (내부 클래스로 변경)
```kotlin
class Car(private val model: String, private val chargeLevel: Int) {
    private val engine = Engine()

    fun start() {
        engine.start()
        println("$model 시작 완료")
    }

    private inner class Engine {
        fun start() {
            println("충전 레벨 확인: $chargeLevel")
            println("$model의 엔진을 구동합니다.")
        }
    }
}
```

### ✅ 실행 결과
```
충전 레벨 확인: 100
Model Y의 엔진을 구동합니다.
Model Y 시작 완료
```

## 🎯 리팩토링 효과 비교 (Kotlin 기준)
| 항목                   | 외부 클래스 구조 (`Car`, `Engine`) | 내부 클래스 구조 (`Engine` ⊂ `Car`) |
|------------------------|-------------------------------------|--------------------------------------|
| 클래스 구조             | `Car`, `Engine` 분리                | `Engine`은 `Car` 내부에 포함          |
| 접근 제어              | `Engine`은 `Car`의 private 멤버 접근 불가 | `Engine`은 `Car`의 private 멤버 직접 접근 가능 |
| 캡슐화 수준             | 낮음 – getter로 외부 노출 필요        | 높음 – 내부에서 직접 접근 가능        |
| 외부 노출 클래스 수     | 2개 (`Car`, `Engine`)               | 1개 (`Car`)                          |
| 논리적 그룹화           | 약함 – 구조적으로 분리됨             | 강함 – `Engine`은 `Car`의 구성 요소   |
| 유지보수 및 가독성      | 클래스 간 의존성 파악 필요            | 구조적으로 명확함                    |
| 생성 방식              | `Engine(car)`                       | `Engine()` (내부에서 생성)           |


### 🔍 Kotlin의 장점
- 내부 클래스는 inner 키워드를 통해 바깥 클래스의 모든 멤버에 접근 가능
- 외부에서 사용되지 않는 클래스는 바깥 클래스 내부에 정의함으로써 캡슐화와 가독성을 높일 수 있음
- Kotlin은 data class, object, sealed class 등 다양한 중첩 구조를 지원하여 더 유연한 설계가 가능


## 🧠 변수 섀도잉(Shadowing) – Kotlin 버전
### ✅ 예제 코드
```kotlin
class ShadowingMain {
    val value = 1 // 바깥 클래스의 인스턴스 변수

    inner class Inner {
        val value = 2 // 내부 클래스의 인스턴스 변수

        fun go() {
            val value = 3 // 지역 변수
            println("value = $value") // 지역 변수
            println("this.value = ${this.value}") // 내부 클래스의 변수
            println("ShadowingMain.value = ${this@ShadowingMain.value}") // 바깥 클래스의 변수
        }
    }
}

fun main() {
    val main = ShadowingMain()
    val inner = main.Inner()
    inner.go()
}
```

### ✅ 실행 결과
```
value = 3
this.value = 2
ShadowingMain.value = 1
```


## 🔍 우선순위 규칙 (Kotlin 기준)

| 참조 방식             | 설명                                      | 우선순위 | 예시 출력값 |
|----------------------|-------------------------------------------|----------|-------------|
| `value`              | 가장 가까운 지역 변수                     | 🔴 가장 높음 | 3           |
| `this.value`         | 내부 클래스의 인스턴스 변수               | 🟠 중간     | 2           |
| `this@Outer.value`   | 바깥 클래스의 인스턴스 변수               | 🟢 가장 낮음 | 1           |

## ✅ 해설
- value: 메서드 내부에서 선언된 지역 변수. 가장 가까운 범위에 있으므로 가장 먼저 참조됨.
- this.value: 내부 클래스의 멤버 변수. 지역 변수에 가려질 수 있지만 this로 명시적으로 접근 가능.
- this@Outer.value: 바깥 클래스의 멤버 변수. 내부 클래스에서 바깥 인스턴스를 참조할 때 사용하는 Kotlin 문법.

Kotlin에서는 `this@OuterClassName` 문법을 통해 바깥 클래스의 인스턴스를 명확하게 참조할 수 있어 가독성이 뛰어납니다.


## 🧩 핵심 요약
- Kotlin에서는 static 키워드 대신 companion object를 사용하며, 중첩 클래스는 기본적으로 정적 성격
- 내부 클래스는 inner 키워드를 통해 바깥 클래스의 인스턴스에 접근 가능
- 섀도잉은 가까운 범위가 우선되며, Kotlin의 this@Outer 문법으로 명확한 참조가 가능
- 실무에서는 캡슐화, 논리적 그룹화, 가독성 향상을 위해 내부 클래스와 중첩 클래스를 적절히 활용하는 것이 중요

---

##  중첩 클래스

### 📦 예제 시나리오: SecureMessenger 클래스
- 외부 클래스 SecureMessenger는 메시지를 전송하는 역할
- 내부 중첩 클래스 Encryptor는 메시지를 암호화하는 역할
- Encryptor는 외부에서 사용되지 않으므로 중첩 클래스로 정의하여 캡슐화를 강화

#### ✅ Kotlin 코드 예제
```kotlin
class SecureMessenger {

    fun sendMessage(message: String) {
        val encrypted = Encryptor().encrypt(message)
        println("🔐 암호화된 메시지 전송: $encrypted")
    }

    // 중첩 클래스: 외부에서 접근할 필요 없음
    private class Encryptor {
        fun encrypt(text: String): String {
            // 간단한 Caesar Cipher 방식으로 암호화
            return text.map { char ->
                if (char.isLetter()) {
                    val base = if (char.isUpperCase()) 'A' else 'a'
                    ((char - base + 3) % 26 + base.code).toChar()
                } else {
                    char
                }
            }.joinToString("")
        }
    }
}

fun main() {
    val messenger = SecureMessenger()
    messenger.sendMessage("Hello Kotlin")
}
```


#### ✅ 실행 결과
```
🔐 암호화된 메시지 전송: Khoor Nrwolq
```

### 🎯 실무 적용 포인트

| 항목               | 설명                                                         |
|--------------------|--------------------------------------------------------------|
| EncryptorSecureMessenger | `Encryptor`는 `SecureMessenger` 내부에서만 사용됨. 외부 노출 불필요 |
| private class Encryptor | `Encryptor`를 `private` 중첩 클래스로 선언하여 외부 접근 차단       |
| SecureMessenger     | 메시지 전송 기능만 외부에 노출. 암호화 로직은 내부에 캡슐화됨         |

### ✅ 핵심 요약
- 캡슐화 강화: Encryptor는 외부에서 접근할 수 없도록 private으로 선언
- 논리적 그룹화: 암호화 기능은 메시지 전송 기능의 일부로 자연스럽게 묶임
- 가독성 향상: SecureMessenger만 보면 전체 흐름을 이해할 수 있어 유지보수에 유리


## inner class

### 📱 예제 시나리오: SmartPhone과 Battery
- SmartPhone은 외부에 노출되는 주 클래스
- Battery는 스마트폰 내부에서만 사용되는 구성 요소로, inner class로 정의
- Battery는 SmartPhone의 인스턴스 멤버에 직접 접근 가능

#### ✅ Kotlin 코드 예제
```kotlin
class SmartPhone(private val model: String, private val batteryLevel: Int) {

    private val battery = Battery()

    fun checkBattery() {
        battery.status()
    }

    // 내부 클래스: 바깥 클래스의 멤버에 접근 가능
    inner class Battery {
        fun status() {
            println("📱 모델명: $model")
            println("🔋 배터리 잔량: $batteryLevel%")
            if (batteryLevel >= 80) {
                println("✅ 배터리 상태 양호")
            } else if (batteryLevel >= 30) {
                println("⚠️ 배터리 상태 보통")
            } else {
                println("❌ 배터리 부족! 충전 필요")
            }
        }
    }
}

fun main() {
    val phone = SmartPhone("Galaxy Z Fold", 25)
    phone.checkBattery()
}
```


#### ✅ 실행 결과
```
📱 모델명: Galaxy Z Fold
🔋 배터리 잔량: 25%
❌ 배터리 부족! 충전 필요

```

## 🎯 실무 적용 포인트 (Kotlin – inner class)
| 항목                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| BatterySmartPhone        | `Battery`는 `SmartPhone` 내부에서만 사용되며 외부에 노출되지 않음         |
| BatterymodelbatteryLevel | `Battery`는 `SmartPhone`의 `model`, `batteryLevel`에 직접 접근 가능       |
| Batteryprivate inner class | `Battery`를 `private inner class`로 선언하여 외부 접근을 완전히 차단       |
| BatterySmartPhone        | `Battery`는 `SmartPhone`의 구성 요소로 논리적으로 그룹화됨               |



### ✅ 핵심 요약
- 캡슐화 강화: Battery는 외부에서 접근할 수 없도록 private inner class로 선언
- 구조적 명확성: Battery는 SmartPhone의 일부로 동작하며, 클래스 간 관계가 명확함
- 가독성 향상: SmartPhone만 보면 전체 기능 흐름을 이해할 수 있어 유지보수에 유리
- 실무 적합성: 외부에서 사용되지 않는 구성 요소는 내부 클래스로 정의하는 것이 바람직


---
# 익명 클래스
val runnable = object : Runnable { ... } 문법은 **익명 클래스(anonymous class)** 를 생성하는 방식.  
이 문법은 Java의 new Runnable() { ... }와 유사하지만 Kotlin에서는 훨씬 더 간결하고 직관적으로 표현됩니다.

## 🧠 문법 구조 분석
```kotlin
val runnable = object : Runnable {
    override fun run() {
        println("익명 클래스 실행")
    }
}
```

## ✅ 구성 요소 설명 (Kotlin 익명 클래스)
| 코드 요소             | 설명                                  |
|----------------------|---------------------------------------|
| `object`             | 이름 없는 객체를 생성하는 키워드         |
| `: Runnable`         | `Runnable` 인터페이스를 구현함          |
| `{ ... }`            | `run()` 메서드를 구현하는 코드 블록     |
| `val runnable = ...` | 익명 객체를 `runnable` 변수에 저장       |

## 🔍 익명 클래스란?
- 이름 없이 정의된 클래스로, 일회성 객체를 만들 때 사용
- 주로 리스너, 콜백, 스레드 실행 등에서 활용됨
- Kotlin에서는 object : 인터페이스 { ... } 또는 object : 클래스() { ... } 형태로 사용

## ✅ 예제: 스레드 실행
```kotlin
fun main() {
    val thread = Thread(object : Runnable {
        override fun run() {
            println("백그라운드 작업 실행 중...")
        }
    })
    thread.start()
}
```
- object : Runnable은 Runnable 인터페이스를 구현한 익명 객체를 생성하고, Thread에 전달합니다.

## 🎯 Kotlin의 장점
- Kotlin은 object 표현식을 통해 익명 클래스 생성이 간결하고 명확함
- 람다 표현식이 가능한 경우에는 Runnable { ... }처럼 더 간단하게 표현 가능
```kotlin
val thread = Thread {
    println("람다로 실행된 스레드")
}
``
- 단, 람다 표현식은 인터페이스에 추상 메서드가 하나일 때만 사용 가능 (SAM: Single Abstract Method)


## 🧩 핵심 요약
- object : Runnable { ... }는 Kotlin에서 익명 클래스를 생성하는 문법
- 이름 없는 클래스를 즉석에서 정의하고, 인터페이스나 클래스를 구현할 수 있음
- 람다로 대체할 수 있는 경우에는 더 간결하게 표현 가능

---

