# 🧠 Kotlin 기본형 vs 참조형 공유 정리

## 1️⃣ 기본형 (Primitive-like Type)
- Int, Double, Boolean 등
- 값 자체를 복사해서 대입 → 절대로 공유되지 않음
  
### 예제
```kotlin
var a = 10
var b = a // 값 복사
b = 20
```

### 결과
```
a = 10
b = 20
```
- a와 b는 각각 독립된 값을 가짐
- b를 변경해도 a는 영향 없음

## 2️⃣ 참조형 (Reference Type)
- 클래스, 배열, 리스트 등
- 참조값(주소)을 복사해서 대입 → 객체 공유 가능
  
### 예제
```kotlin
data class Address(var value: String)

val a = Address("서울")
val b = a
b.value = "부산"
```

### 결과
```
a = Address(value=부산)
b = Address(value=부산)
```

- a와 b는 같은 객체(x001)를 참조
- b를 통해 값을 변경하면 a도 함께 변경됨

## 3️⃣ 사이드 이펙트 (Side Effect)
- 참조형 변수 공유로 인해 의도치 않은 변경이 발생하는 현상
### 예제
```kotlin
fun change(address: Address, newValue: String) {
    address.value = newValue
}

change(b, "부산")
```
- b를 변경했지만 a도 함께 변경됨 → 사이드 이펙트 발생

## 4️⃣ 해결 방법
### ✅ 서로 다른 객체를 참조
```kotlin
val a = Address("서울")
val b = Address("서울")
```
- a와 b는 각각 다른 인스턴스를 참조
- b.value = "부산" → a는 영향 없음

## 5️⃣ 객체 공유를 막을 수 없는 이유
- 코틀린도 참조값을 복사함

```kotlin
val b = a // 참조값 복사 → 공유 발생
```

- 문법상 문제 없음
- 개발자가 실수로 객체를 공유해도 컴파일 오류 없음

## 6️⃣ 실무 팁 — 참조형 공유와 사이드 이펙트 방지
| 상황                         | 권장 방식                                                  |
|------------------------------|-------------------------------------------------------------|
| 값 변경이 독립적이어야 할 때 | 서로 다른 객체를 생성해서 참조                             |
| 객체 공유가 필요한 경우      | 변경 범위를 명확히 관리하거나 불변 객체 사용                |
| 사이드 이펙트 방지           | 객체 복사 또는 `copy()` 기반 불변 객체 패턴 적용            |
| 함수 인자로 객체 전달 시     | 참조값이 전달된다는 점을 인지하고 주의할 것                 |
| 협업 시 안정성 확보          | 외부에 영향을 주지 않도록 설계. 불변 객체 또는 캡슐화 활용  |

---

# 🧠 Kotlin 불변 객체(Immutable Object) 도입 정리
## 1️⃣ 문제의 본질: 공유된 객체의 값 변경
```kotlin
val a = Address("서울")
val b = a
b.value = "부산" // a도 함께 변경됨 → 사이드 이펙트 발생
```

## 2️⃣ 불변 객체란?
- 상태가 절대 변하지 않는 객체
- val로 선언하고, 변경 메서드 제거
- 생성자에서만 값을 설정 가능

### 예시: 불변 클래스 정의
```kotlin
data class ImmutableAddress(val value: String)
```
## 3️⃣ 불변 객체의 효과
- 값을 변경할 수 없으므로 사이드 이펙트가 원천 차단
- 값을 변경하려면 새로운 객체를 생성해야 함

### 예시
```kotlin
val a = ImmutableAddress("서울")
val b = a
val b2 = ImmutableAddress("부산") // a는 그대로 유지됨
```
## 4️⃣ 가변 vs 불변 객체 비교
| 항목               | MutableObj (가변 객체)                  | ImmutableObj (불변 객체)              |
|--------------------|------------------------------------------|--------------------------------------|
| 선언 방식           | `var value`                              | `val value`                          |
| 값 변경 가능 여부   | 가능 (`value` 직접 수정 가능)             | 불가능 (`val`로 선언, 변경 메서드 없음) |
| 변경 방식           | 내부 필드 직접 수정                       | `copy()` 또는 새 객체 생성            |
| 참조 공유 시 위험   | 높음 (다른 변수도 함께 변경될 수 있음)     | 낮음 (기존 객체는 변경되지 않음)      |
| 예시 결과           | `a`, `b` 모두 부산으로 변경됨             | `a`는 서울 유지, `b`만 부산으로 변경됨 |


## 5️⃣ 실전 예제: 회원 주소 변경

### ❌ 가변 객체 사용 — 사이드 이펙트 발생
```kotlin
val address = Address("서울")
val memberA = MemberV1("회원A", address)
val memberB = MemberV1("회원B", address)

memberB.address.value = "부산" // memberA도 함께 변경됨
```

### ✅ 불변 객체 사용 — 사이드 이펙트 없음
```kotlin
val address = ImmutableAddress("서울")
val memberA = MemberV2("회원A", address)
val memberB = MemberV2("회원B", address)

memberB.address = ImmutableAddress("부산") // memberA는 그대로 유지
```

## 6️⃣ 핵심 정리 — 불변 객체의 원리와 효과
| 항목                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 객체 공유                | 코틀린에서도 참조형 객체는 여러 변수에서 공유 가능                    |
| 사이드 이펙트 발생 조건  | 공유된 객체의 내부 상태가 변경될 때 발생                              |
| 불변 객체의 역할         | 내부 상태 변경을 금지하여 사이드 이펙트를 원천 차단                    |
| 값 변경 방식             | 기존 객체는 유지하고, 변경된 값을 가진 새 객체를 생성하여 반환         |
| `copy()` 패턴            | `data class`에서 일부 값만 바꾼 새 객체를 만들 때 사용하는 메서드       |
| 실무 적용                | 멀티쓰레드, 캐시, 설정값, 도메인 값 타입 등에서 안정성 확보에 유리       |

---

# 🧠 Kotlin 불변 객체에서 값 변경하기 — 핵심 정리

## 1️⃣ 불변 객체의 원칙
- 객체의 상태는 절대 변경되지 않아야 함
- 값을 변경하는 대신 새로운 객체를 생성해서 반환

## 2️⃣ 가변 객체 vs 불변 객체 비교
| 항목               | MutableObj (가변 객체)                  | ImmutableObj (불변 객체)              |
|--------------------|------------------------------------------|--------------------------------------|
| 값 변경 방식        | `add()` 메서드로 내부 상태 직접 변경       | `add()` 메서드가 새 객체를 반환         |
| 내부 상태 변경 여부 | 변경됨                                   | 변경되지 않음                          |
| 참조값 유지 여부    | 동일 객체 내에서 값만 변경됨               | 기존 객체는 유지되고 새 객체 생성됨     |
| 반환값 처리         | 반환값 없이도 상태 변경 가능               | 반환값을 반드시 받아야 변경 결과 활용 가능 |
| 예시 결과           | `10 → 30` (기존 객체 값 덮어씀)            | `10 → 30` (새 객체에 변경값 저장됨)     |

## 3️⃣ 불변 객체에서 값 변경 — add() 예시
```kotlin
data class ImmutableObj(val value: Int) {
    fun add(addValue: Int): ImmutableObj {
        return ImmutableObj(value + addValue)
    }
}
```

### 결과
```kotlin
val obj1 = ImmutableObj(10)
val obj2 = obj1.add(20)

println(obj1.value) // 10
println(obj2.value) // 30
```

## 4️⃣ 반환값을 꼭 받아야 하는 이유
```kotlin
obj1.add(20) // 반환값을 저장하지 않으면 아무 일도 안 일어남
println(obj1.value) // 여전히 10
```

- 불변 객체는 내부 상태를 변경하지 않기 때문에
- 반환된 새 객체를 반드시 변수에 저장해야 함

## 5️⃣ 불변 객체의 변경 메서드 — withXxx() 패턴
```kotlin
data class ImmutableMyDate(val year: Int, val month: Int, val day: Int) {
    fun withYear(newYear: Int): ImmutableMyDate {
        return copy(year = newYear)
    }
}
```

### 예시 결과
```kotlin
val date1 = ImmutableMyDate(2024, 1, 1)
val date2 = date1
val date1Updated = date1.withYear(2025)

println(date1Updated) // 2025-1-1
println(date2)        // 2024-1-1
```

## 6️⃣ 불변 객체를 사용하는 이유
| 목적                   | 설명                                                                 |
|------------------------|----------------------------------------------------------------------|
| 사이드 이펙트 방지      | 공유된 객체의 상태 변경을 원천 차단하여 예측 가능한 동작 보장          |
| 멀티쓰레드 안정성       | 여러 스레드에서 동시에 접근해도 상태 변경이 없으므로 안전함             |
| 캐시 안정성            | 값이 변하지 않으므로 캐싱된 객체를 그대로 재사용 가능                  |
| 도메인 모델의 값 타입   | 엔티티의 속성으로 사용할 때 불변 객체는 설계와 추적이 쉬움              |
| 유지보수와 디버깅 용이  | 상태 변경이 없으므로 코드 흐름 추적이 간단하고 버그 발생 가능성 감소     |

---

# return copy(year = newYear) 

Kotlin에서 return copy(year = newYear)는 불변 객체의 일부 값을 변경한 새 객체를 반환하는 문법.  
이 문법은 data class에서 자동 생성되는 copy() 메서드를 활용한 것으로, 매우 강력하고 직관적인 기능입니다.

## 🔍 문법 구조 설명
```kotlin
return copy(year = newYear)
```
- copy(...)는 현재 객체의 모든 필드를 복사해서 새 객체를 만들되,
- 괄호 안에 지정한 필드(year)만 새 값으로 덮어쓰기 합니다.
- 나머지 필드는 기존 객체의 값을 그대로 유지합니다.

## 📦 예제
```kotlin
data class MyDate(val year: Int, val month: Int, val day: Int)

val date1 = MyDate(2024, 1, 1)
val date2 = date1.copy(year = 2025)

println(date1) // MyDate(year=2024, month=1, day=1)
println(date2) // MyDate(year=2025, month=1, day=1)
```
- date2는 year만 바뀐 새 객체
- date1은 그대로 유지 → 불변성 보장

## ✅ 왜 중요한가?
| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 불변 객체 지원       | `copy()`를 통해 기존 객체를 수정하지 않고 새 객체를 생성할 수 있음         |
| 안전한 값 변경       | 일부 필드만 변경하고 나머지는 유지 → 사이드 이펙트 없이 값 변경 가능         |
| 코드 간결성          | `data class`에서 자동 생성된 `copy()` 덕분에 복사 로직을 직접 구현할 필요 없음 |
| 구조적 일관성        | `data class`는 `equals()`, `hashCode()`, `toString()` 등도 자동 생성되어 안정적 |
| 유지보수 편의성      | 변경이 필요한 필드만 명시하면 되므로 가독성과 유지보수가 쉬움                 |

- 요약하자면, return copy(year = newYear)는 불변 객체의 일부 필드만 바꿔서 새 객체를 만드는 가장 코틀린스러운 방식.

