# 🔐 Kotlin에서의 접근 제어자와 캡슐화

## 🎯 접근 제어자 이해 – 왜 필요한가?
- 클래스 외부에서 필드나 메서드에 접근할 수 있는 범위를 제어함
- 객체의 내부 상태를 보호하고, 잘못된 사용을 방지하기 위해 사용됨

## 📌 Kotlin 접근 제어자 요약
| 접근 제어자 | 클래스 사용가능 | 멤버 사용가능 | 접근 범위 설명                                      | 자바와의 차이점                     |
|-------------|--------------------|------------------|----------------------------------------------------|-------------------------------------|
| `public`      | ✅(기본값)         | ✅         | 모든 클래스, 패키지, 모듈에서 접근 가능              | 자바와 동일                          |
| `private`     | ✅(파일 내부 한정) | ✅          | 같은 클래스 또는 같은 파일 내에서만 접근 가능        | 자바는 클래스 기준, Kotlin은 파일 기준도 포함 |
| `protected`   | ❌(클래스에는 불가) | ✅         | 클래스 내부 + 상속 관계에서만 접근 가능              | Kotlin은 패키지 접근 불가            |
| `internal`    | ✅                  | ✅        | 같은 모듈 내에서만 접근 가능                         | 자바에는 없음                        |


## 🧩 Kotlin 예제: Speaker 클래스
### ❌ 잘못된 설계 (volume이 공개됨)
```kotlin
class Speaker(var volume: Int) {
    fun volumeUp() {
        if (volume >= 100) {
            println("음량을 증가할 수 없습니다. 최대 음량입니다.")
        } else {
            volume += 10
            println("음량을 10 증가합니다.")
        }
    }

    fun volumeDown() {
        volume -= 10
        println("volumeDown 호출")
    }

    fun showVolume() {
        println("현재 음량: $volume")
    }
}
```

- 외부에서 speaker.volume = 200처럼 직접 수정 가능 → 위험

### ✅ 캡슐화 적용 (volume을 private으로 숨김)
```kotlin
class Speaker(private var volume: Int) {

    fun volumeUp() {
        if (volume >= 100) {
            println("음량을 증가할 수 없습니다. 최대 음량입니다.")
        } else {
            volume += 10
            println("음량을 10 증가합니다.")
        }
    }

    fun volumeDown() {
        volume -= 10
        println("volumeDown 호출")
    }

    fun showVolume() {
        println("현재 음량: $volume")
    }
}
```

- 외부에서 직접 volume 수정 불가
- 클래스 내부 메서드를 통해서만 상태 변경 가능

### 🧪 Kotlin 접근 제어자 실습 예제
```kotlin
class AccessData {
    public var publicField = 0
    internal var internalField = 0
    private var privateField = 0

    public fun publicMethod() { println("publicMethod") }
    internal fun internalMethod() { println("internalMethod") }
    private fun privateMethod() { println("privateMethod") }

    fun innerAccess() {
        publicField = 1
        internalField = 2
        privateField = 3
        publicMethod()
        internalMethod()
        privateMethod()
    }
}
```
- 같은 모듈에서는 internal까지 접근 가능
- 클래스 외부에서는 private 접근 불가

## 🔐 캡슐화란?
객체의 데이터와 기능을 하나로 묶고, 외부에는 꼭 필요한 기능만 공개하는 객체 지향의 핵심 원칙

## 🎯 캡슐화의 목적
| 목적             | 설명                                                                 | Kotlin 적용 방식         |
|------------------|----------------------------------------------------------------------|---------------------------|
| 데이터 보호       | 외부에서 직접 필드에 접근하지 못하게 막아, 잘못된 변경을 방지함         | `private` 프로퍼티 사용    |
| 기능 제한         | 내부에서만 사용하는 기능은 숨겨서 사용자 혼란을 줄이고 안정성을 높임     | `private` 함수로 내부 로직 분리 |
| 복잡도 감소       | 꼭 필요한 기능만 노출하여 사용자가 객체를 쉽게 이해하고 사용할 수 있음   | `public` 함수만 외부에 공개 |
| 유지보수 용이     | 내부 구현을 자유롭게 변경해도 외부에 영향을 주지 않아 관리가 쉬움        | 내부 구조 변경 → 외부 영향 없음 |
| 무결성 보장       | 모든 데이터 변경이 검증된 메서드를 통해 이루어져 일관성과 안정성이 유지됨 | 검증 로직 포함한 `public` 메서드 |



## 🧩 Kotlin 예제: BankAccount 클래스
```kotlin
class BankAccount {
    private var balance = 0

    fun deposit(amount: Int) {
        if (isAmountValid(amount)) {
            balance += amount
        } else {
            println("유효하지 않은 금액입니다.")
        }
    }

    fun withdraw(amount: Int) {
        if (isAmountValid(amount) && balance >= amount) {
            balance -= amount
        } else {
            println("유효하지 않은 금액이거나 잔액이 부족합니다.")
        }
    }

    fun getBalance(): Int = balance

    private fun isAmountValid(amount: Int): Boolean = amount > 0
}
```

- balance와 isAmountValid()는 private으로 숨김
- 외부에서는 deposit(), withdraw(), getBalance()만 사용 가능

## 🚗 캡슐화 비유
- 운전자는 핸들, 엑셀, 브레이크만 사용
- 엔진, 배기 시스템은 내부에 숨겨져 있음
- 사용자는 필요한 기능만 사용하고 내부는 안전하게 보호됨

## ✅ 결론
- 자바의 default는 Kotlin에 없음 → internal이 유사하지만 패키지가 아닌 모듈 기준
- Kotlin은 접근 제어자가 더 단순하고 명확함
- 클래스 레벨에서는 Kotlin이 public, internal, private만 허용

## 🎯 캡슐화 예제
### 1️⃣ MaxCounter 클래스
```kotlin
class MaxCounter(private val max: Int) {
    private var count: Int = 0

    fun increment() {
        if (count >= max) {
            println("최대값을 초과할 수 없습니다.")
            return
        }
        count++
    }

    fun getCount(): Int = count
}
```

- count와 max는 private으로 외부 접근 차단
- increment()와 getCount()만 외부에 공개

### 2️⃣ Item 클래스
```kotlin
class Item(
    private val name: String,
    private val price: Int,
    private val quantity: Int
) {
    fun getName(): String = name
    fun getTotalPrice(): Int = price * quantity
}
```

- 모든 속성은 private
- 외부에서는 getName()과 getTotalPrice()만 사용 가능

### 3️⃣ ShoppingCart 클래스
```kotlin
class ShoppingCart {
    private val items = ArrayList<Item>()
    private val maxItems = 10

    fun addItem(item: Item) {
        if (items.size >= maxItems) {
            println("장바구니가 가득 찼습니다.")
            return
        }
        items.add(item)
    }

    fun displayItems() {
        println("장바구니 상품 출력")
        for (item in items) {
            println("상품명: ${item.getName()}, 합계: ${item.getTotalPrice()}")
        }
        println("전체 가격 합: ${calculateTotalPrice()}")
    }

    private fun calculateTotalPrice(): Int {
        return items.sumOf { it.getTotalPrice() }
    }
}
```

- items 리스트와 calculateTotalPrice()는 private
- 외부에서는 addItem()과 displayItems()만 사용 가능

## 📦 캡슐화의 효과 요약 (Kotlin 관점)

| 효과             | 설명                                                                 | 접근 제어자 |
|------------------|----------------------------------------------------------------------|--------------|
| 데이터 보호       | 외부에서 직접 수정 불가 → 무결성 유지                                 | private       |
| 내부 로직 숨김    | 복잡하거나 검증이 필요한 로직은 외부에 노출하지 않음                   | private       |
| 기능 제공         | 필요한 기능만 외부에 공개 → 사용자가 쉽게 접근 가능                    | public        |
| 유지보수 용이     | 내부 구현 변경 시 외부 영향 없음 → 안정적인 코드 관리 가능             | private/public|
| 객체 책임 분리    | 객체가 스스로 상태를 관리하고 검증 → 외부는 결과만 신뢰하면 됨         | public/private|

---

## 🔍 Kotlin vs Java 접근 제어자 비교

| 접근 제어자 | Java 기준 설명                                      | Kotlin 기준 설명                                      | 주요 차이점                          | 사용 위치                  |
|-------------|------------------------------------------------------|--------------------------------------------------------|--------------------------------------|-----------------------------|
| public      | 모든 클래스, 패키지에서 접근 가능                     | 모든 클래스, 패키지, 모듈에서 접근 가능 (기본값)        | 거의 동일                            | 클래스, 함수, 프로퍼티 등   |
| private     | 클래스 내부에서만 접근 가능                           | 클래스 또는 파일 내부에서만 접근 가능                   | Kotlin은 파일 단위도 포함            | 클래스, 파일, 객체 등       |
| protected   | 같은 패키지 + 자식 클래스에서 접근 가능               | 자식 클래스에서만 접근 가능 (패키지 접근 불가)          | Kotlin은 패키지 접근 불가            | 클래스 멤버에만 사용 가능   |
| default     | 키워드 없이 선언 → 같은 패키지에서만 접근 가능         | 없음 (`internal`이 유사하지만 모듈 기준)                | Kotlin에는 default 없음              | 클래스, 필드, 메서드 등     |
| internal    | 없음                                                  | 같은 모듈 내에서만 접근 가능                            | Kotlin 전용 접근 제어자              | 클래스, 함수, 프로퍼티 등   |

## 💡 핵심 요약
- Kotlin은 default 대신 internal을 제공하며, 패키지 단위가 아닌 모듈 단위로 접근을 제어함
- private는 Kotlin에서 파일 단위로도 적용 가능 → top-level 함수 숨기기에 유용
- protected는 Kotlin에서 상속 관계만 허용, 패키지 접근은 불가능


---
