# ✅ Kotlin에서 변경 불가 개념 정리

## 🧠 변경 불가 변수와 상수

### 📌 1. Kotlin에서 변경 불가 이란?
- Kotlin은 `final` 키워드를 변수에 직접 사용하지 않음
- 대신 `val` 로 한 번만 할당 가능한 변수를 선언함
- 클래스, 메서드, 프로퍼티에는 변경 불가가 기본이며, `open` 을 명시해야 오버라이딩 가능

### 🧪 2. 지역 변수 예제
```kotlin
val data1: Int
data1 = 10     // ✅ 최초 1회 할당 가능
// data1 = 20  // ❌ 컴파일 오류

val data2 = 10
// data2 = 20  // ❌ 컴파일 오류
```

- val은 한 번만 값을 할당할 수 있음
- 초기화 전이라도 단 한 번만 할당 가능

### 📌 3. 함수 매개변수
```kotlin
fun method(parameter: Int) {
    // parameter = 20 // ❌ 컴파일 오류
}
```

- Kotlin의 함수 매개변수는 기본적으로 `val` 처럼 동작
- 내부에서 값을 변경할 수 없음

### 🧩 4. 클래스 프로퍼티
#### ✅ 생성자 초기화
```kotlin
class ConstructInit(val value: Int)
```
- val은 생성자에서 초기화되고 이후 변경 불가
- 각 인스턴스마다 다른 값을 가질 수 있음

#### ✅ 필드에서 직접 초기화
```kotlin
class FieldInit {
    val value: Int = 10
}
```
- 모든 인스턴스가 동일한 값을 가짐
- 생성자에서 다시 초기화할 수 없음

### 🔒 5. 상수 정의 (const val)
```kotlin
object Constant {
    const val PI = 3.14
    const val MAX_USERS = 1000
}
```

- `const val` 은 컴파일 타임 상수
- `object` 내부에 선언해야 함
- 접근 방식: `Constant.MAX_USERS`

#### 🔍 차이점 요약: val vs const val
| 키워드       | 의미               | 사용 시점     | 사용 위치                  | 제한 사항                          |
|--------------|--------------------|----------------|-----------------------------|-------------------------------------|
| `val`          | 변경 불가 변수      | 런타임         | 어디서든 사용 가능           | 참조값은 고정, 내부 값은 변경 가능 |
| `const val`    | 컴파일 타임 상수    | 컴파일 시점    | object 또는 top-level에서만 | 리터럴만 가능, 클래스 내부 선언 불가 |


### ⚠️ 6. 매직 넘버 문제 해결
#### ❌ 직접 숫자 사용
```kotlin
if (currentUserCount > 1000) { ... } // 의미 불명확
```

#### ✅ 상수 사용
```kotlin
if (currentUserCount > Constant.MAX_USERS) { ... } // 의미 명확
```

- 유지보수 용이
- 의미 전달이 명확함

## ✅ 핵심 요약: Kotlin에서 final 개념
| 용도/개념           | Kotlin 방식             | 설명                                       |
|--------------------|-------------------------|--------------------------------------------|
| 지역 변수 변경 금지 | `val`                    | 최초 1회만 할당 가능, 이후 변경 불가         |
| 클래스 필드 변경 금지 | `val`                     | 생성자 또는 필드에서 초기화, 이후 변경 불가   |
| 클래스 상수         | `const val` + `object`      | 컴파일 타임 상수, 클래스 수준에서 공유됨     |
| 상수 작명 관례       | `MAX_USERS`, `PI`           | 모두 대문자 + 언더스코어로 명명              |
| 참조값 고정         | `val`                     | 참조값 변경 불가, 객체 내부 값은 변경 가능    |

---

# 🧠 참조형 변수와 변경 불가 개념
## 📌 1. Kotlin에서 참조 변경 금지
- val은 참조값 변경 불가
- 객체 내부 값은 변경 가능

## 🧩 2. 기본형 vs 참조형
| 변수 종류     | 저장 내용         | val 적용 시 의미                                      |
|--------------|------------------|--------------------------------------------------------|
| `기본형 변수`   | 값 자체 (예: 10)   | 값을 변경할 수 없음 (재할당 불가)                      |
| `참조형 변수`   | 객체의 참조값      | 참조값 변경 불가 (다른 객체로 변경 불가), 객체 내부 값은 변경 가능 |


## 🧪 3. 참조형 변수 예제
```kotlin
class Data(var value: Int)

val data = Data(10)     // 참조값 고정
data.value = 20         // ✅ 내부 값은 변경 가능
// data = Data(30)      // ❌ 참조값 변경 불가
```

- `val` 은 참조값을 고정하지만
- 객체 내부의 `var` 프로퍼티는 변경 가능

## 🔐 4. 실전 예제: 고객 ID 보호
```kotlin
class Member(private val id: String, var name: String) {

    fun changeData(id: String, name: String) {
        // this.id = id     // ❌ 컴파일 오류
        this.name = name    // ✅ 변경 가능
    }

    fun print() {
        println("id:$id, name:$name")
    }
}
```

## 🖥️ 실행 결과
```
val member = Member("myId", "kim")
member.print()           // id:myId, name:kim
member.changeData("newId", "seo")
member.print()           // id:myId, name:seo
```

- id는 `val` 이라 변경 불가
- name은 `var` 이라 변경 가능

---
# `open`

Kotlin에서 `open` 키워드는 자바와 달리 명시적으로 "열어줘야" 오버라이딩이 가능한 구조.  
기본적으로 모든 클래스, 메서드, 프로퍼티는 final로 닫혀 있고, open을 붙여야 상속이나 재정의가 가능.

## 🔍 Kotlin의 open 키워드 개요
| 대상         | 기본 상태 | open 사용 시 의미                  |
|--------------|------------|------------------------------------|
| 클래스       | final      | class A : B() → 상속 가능           |
| 메서드       | final      | override → 자식 클래스에서 재정의 가능 |
| 프로퍼티     | final      | override → getter/setter 재정의 가능 |


## 🧩 클래스에서 open
```kotlin
open class Animal {
    fun speak() = println("Animal sound")
}
class Dog : Animal() // ✅ 가능
```

- `open` 이 없으면 Animal을 상속할 수 없음
- Kotlin은 기본적으로 클래스 상속을 막음 → 명시적으로 열어야 함

## 🧪 메서드에서 open
```kotlin
open class Animal {
    open fun speak() = println("Animal sound")
}

class Dog : Animal() {
    override fun speak() = println("Bark")
}
```

- `open` 이 없으면 speak()를 오버라이드할 수 없음
- `override` 는 반드시 `open` 된 메서드에만 사용 가능

## 🧬 프로퍼티에서 open
```kotlin
open class Animal {
    open val sound: String = "Generic"
}

class Dog : Animal() {
    override val sound: String = "Bark"
}
```
- val/var도 open을 붙여야 오버라이딩 가능
- `getter`/`setter` 를 재정의할 수 있음

## 🚫 기본은 닫혀 있음
```kotlin
class Animal {
    fun speak() = println("Animal sound")
}

class Dog : Animal() {
    // override fun speak() ❌ 오류: speak는 final임
}
```

- Kotlin은 자바와 달리 기본적으로 모든 것이 final
- 명시적으로 `open` 을 붙여야 확장 가능

## ✅ 핵심 요약: Kotlin의 open과 override
| 키워드     | 필요 조건 또는 역할             | 설명                                           |
|------------|-------------------------------|------------------------------------------------|
| open       | 명시적으로 열어야 상속/재정의 가능 | 클래스, 메서드, 프로퍼티 기본은 final 상태         |
| override   | open 대상에만 사용 가능         | 자식 클래스에서 메서드나 프로퍼티를 재정의할 때 사용 |
| 클래스 기본 | final                         | 상속하려면 open 필요                            |
| 메서드 기본 | final                         | 오버라이딩하려면 open 필요                      |
| 프로퍼티 기본 | final                         | getter/setter 재정의하려면 open 필요             |

---

## ✅ 프로퍼티란?
- Kotlin에서 `val` 또는 `var` 로 선언된 멤버는 자동으로 `getter`/`setter` 가 생성됨
- val → 읽기 전용 → getter만 생성됨
- var → 읽기/쓰기 가능 → getter + setter 생성됨
```kotlin
var name: String = "JungHwan"
    get() = field.uppercase()
    set(value) {
        field = value.trim()
    }

```
- 위 코드는 `name` 이라는 프로퍼티에 커스텀 `getter`/`setter` 를 정의한 예시
- field는 Kotlin이 내부적으로 제공하는 백킹 필드(`backing field`)

## 💡 용어 정리
| 용어           | 의미                                                   |
|----------------|--------------------------------------------------------|
| `필드 (field)`   | 실제 데이터를 저장하는 공간 (메모리 상의 값)             |
| `프로퍼티`       | 필드 + getter/setter 로 구성된 접근 가능한 인터페이스     |
| `getter`         | 프로퍼티의 값을 읽을 때 호출되는 함수                    |
| `setter`         | 프로퍼티의 값을 설정할 때 호출되는 함수 (`var`일 때만)   |
| `backing field`  | `field` 키워드로 참조되는 내부 저장소 (getter/setter 내부에서 사용) |


## 🔍 backing field란?
- Kotlin에서 프로퍼티를 선언하면 컴파일러가 자동으로 생성하는 내부 저장소
- 커스텀 getter나 setter에서 field라는 키워드로 접근 가능
- 외부에서는 직접 접근 불가능 → 오직 get/set 내부에서만 사용 가능

### ✅ 예제
```kotlin
var name: String = "JungHwan"
    get() {
        println("getter 호출됨")
        return field // backing field
    }
    set(value) {
        println("setter 호출됨: $value")
        field = value.trim() // backing field에 저장
    }
```
- 여기서 `field` 는 우리가 선언한 name 프로퍼티의 값을 저장하는 공간
- `field` 는 자동 생성되며, 우리가 직접 선언하지 않아도 됨

### ⚠️ 주의할 점
- field는 getter/setter 내부에서만 사용 가능
- 프로퍼티에 get()만 있고 field를 참조하지 않으면 backing field는 생성되지 않음
  
```kotlin
val message: String
    get() = "Hello" // backing field 없음
```

## 💡 핵심 요약: Kotlin의 field와 backing field
| 개념             | 설명                                                   |
|------------------|--------------------------------------------------------|
| field            | Kotlin이 자동 생성하는 내부 저장소 (backing field)       |
| 접근 가능 위치     | getter/setter 내부에서만 사용 가능                       |
| 생성 조건         | `field` 키워드를 참조하면 자동 생성됨                    |
| 역할             | 프로퍼티의 실제 값을 저장하고 관리함                      |
| 외부 접근 여부     | ❌ 외부에서는 직접 접근 불가 (캡슐화됨)                   |

---

# 프로퍼티 override

Kotlin에서 프로퍼티를 `override` 하더라도, 객체를 부모 타입으로 업캐스팅하면 부모 클래스에 정의된 프로퍼티 버전으로 접근하게 됩니다.  
즉, 정적 타입(Static Type)에 따라 접근하는 프로퍼티가 달라질 수 있음.

## 🔍 핵심 개념: 정적 타입 vs 동적 타입
- Kotlin은 메서드는 동적 디스패치, 프로퍼티는 정적 디스패치를 따름
- 즉, override된 프로퍼티라도 부모 타입으로 접근하면 부모의 프로퍼티 값이 사용됨

## 🧪 예제 코드
```kotlin
open class Parent {
    open val message: String = "Parent"
}

class Child : Parent() {
    override val message: String = "Child"
}

fun main() {
    val child = Child()
    println(child.message)           // 🔹 출력: Child

    val parent: Parent = child
    println(parent.message)         // 🔸 출력: Parent ← 정적 타입 기준
}
```

- child.message는 Child의 override된 값 사용
- parent.message는 Parent 타입 기준으로 접근 → Parent의 값 사용됨

### ⚠️ 왜 이런가요?
- Kotlin의 프로퍼티는 필드처럼 접근되기 때문에 정적 타입 기준으로 결정됨
- 메서드는 항상 동적으로 디스패치되므로 override된 메서드는 자식 버전이 호출됨

### ✅ 해결 방법: getter 오버라이딩
```kotlin
open class Parent {
    open val message: String
        get() = "Parent"
}

class Child : Parent() {
    override val message: String
        get() = "Child"
}
```

#### ➡️ 이렇게 하면 parent.message도 "Child"로 출력됨
왜냐하면 이제 getter 함수가 동적으로 디스패치되기 때문이에요

## 💡 핵심 요약: 프로퍼티 override와 타입별 접근
| 접근 방식           | 결과 값         | 설명                                           |
|--------------------|------------------|------------------------------------------------|
| Child.message       | "Child"          | 자식 타입으로 접근 → override된 값 사용         |
| (Parent)child.message | "Parent"        | 부모 타입으로 업캐스팅 → 부모의 값 사용 (정적 디스패치) |
| getter 오버라이딩 사용 | "Child"          | 부모 타입이어도 자식의 getter가 호출됨 (동적 디스패치) |


## 🔍 C#에서 프로퍼티 override 구조
### 1️⃣ 기본 문법
```csharp
public class Parent {
    public virtual string Message => "Parent";
}

public class Child : Parent {
    public override string Message => "Child";
}
```
- Parent.Message는 virtual로 선언되어야 Child에서 override 가능
- override된 프로퍼티는 객체의 실제 타입 기준으로 동작함 → 동적 디스패치

### 2️⃣ 업캐스팅 후 접근
```csharp
Parent obj = new Child();
Console.WriteLine(obj.Message); // 출력: "Child"
```

- C#에서는 프로퍼티도 메서드처럼 동적 디스패치됨
- Kotlin과 달리 Parent 타입으로 접근해도 Child의 override된 값이 출력됨

## ✅ Kotlin과 C#의 차이점 요약

| 항목               | Kotlin                          | C#                                      |
|--------------------|----------------------------------|------------------------------------------|
| 기본 상태           | 모든 클래스/프로퍼티는 final       | 모든 클래스/프로퍼티는 기본적으로 virtual 아님 |
| 오버라이딩 조건     | `open` 필요                      | `virtual`, `abstract`, `override` 필요     |
| 디스패치 방식       | 기본은 정적 디스패치 (getter로 동적 가능) | 프로퍼티도 메서드처럼 동적 디스패치됨        |
| 업캐스팅 후 결과     | 부모 타입 기준 값 사용됨             | 자식 타입 기준 값 사용됨                   |
| override 키워드 사용 | `open`된 대상에만 가능              | `virtual` 또는 `abstract` 기반에만 가능     |

---

# Java

Java에서도 프로퍼티(필드)는 override가 불가능하며, 메서드만 오버라이딩 가능합니다.  
프로퍼티처럼 보이는 동작을 하려면 getter 메서드를 override해야 합니다.

## 🔍 Java에서 프로퍼티 override의 핵심
### ✅ 필드는 override 불가 → "숨김(hiding)"만 가능
```java
class Parent {
    public String message = "Parent";
}

class Child extends Parent {
    public String message = "Child";
}


Parent obj = new Child();
System.out.println(obj.message); // 출력: "Parent"
```

- message는 숨겨짐(hiding) → 부모 타입으로 접근하면 부모의 필드 사용됨
- 오버라이딩이 아님 → 정적 디스패치

### ✅ getter 메서드를 override하면 동적 디스패치 가능
```java
class Parent {
    public String getMessage() {
        return "Parent";
    }
}

class Child extends Parent {
    @Override
    public String getMessage() {
        return "Child";
    }
}


Parent obj = new Child();
System.out.println(obj.getMessage()); // 출력: "Child"
```

- 메서드는 동적 디스패치 → 실제 객체 타입 기준으로 동작
- Kotlin에서 getter 오버라이딩과 동일한 방식

## ✅ Kotlin vs Java vs C# 비교 요약
| 항목               | Kotlin             | Java                | C#                      |
|--------------------|--------------------|---------------------|--------------------------|
| 기본 상태           | final              | non-final           | non-virtual              |
| 오버라이딩 조건     | open               | @Override + method  | virtual → override       |
| 필드 override       | 불가 (정적 디스패치) | 불가 (숨김만 가능)   | 불가 (숨김만 가능)         |
| getter override     | 가능 (동적 디스패치) | 가능 (동적 디스패치) | 가능 (동적 디스패치)       |
| 업캐스팅 후 결과     | 부모 값 사용됨       | 부모 값 사용됨        | 자식 값 사용됨             |


----

## 예제: message를 override하고 부모 함수에서 접근할 때
```kotlin
open class Parent {
    open val message: String = "Parent"
    fun getParentMessage(): String {
        return message
    }
}

class Child : Parent() {
    override val message: String = "Child"
    fun getChildMessage(): String {
        return message
    }
}
```

## 🔍 실행 코드
```kotlin
fun main() {
    val child = Child()

    println(child.getParentMessage()) // 출력: "Child"
    println(child.getChildMessage())  // 출력: "Child"
}
```

## ✅ 결과 설명: Kotlin에서 open 프로퍼티 접근 결과
| 호출 방식               | 결과 값   | 조건 또는 이유               |
|------------------------|-----------|------------------------------|
| child.getParentMessage() | "Child"   | `message`가 open이라 동적 디스패치 |
| child.getChildMessage()  | "Child"   | 자식 클래스에서 직접 접근        |

- message가 open이기 때문에, 부모 클래스의 함수에서 접근하더라도 자식의 override된 값이 사용됨
- Kotlin은 프로퍼티 자체는 정적 디스패치지만, open val은 getter를 통해 동적 디스패치가 적용됨

## ⚠️ 만약 message가 open이 아니었다면?
```kotlin
open class Parent {
    val message: String = "Parent" // ❌ open 없음
    fun getParentMessage() = message
}

class Child : Parent() {
    val message: String = "Child" // 숨김(hiding)
    fun getChildMessage() = message
}


val child = Child()
println(child.getParentMessage()) // 출력: "Parent"
println(child.getChildMessage())  // 출력: "Child"
```

- 이 경우는 정적 디스패치 → 부모 함수에서는 부모의 message 사용됨
- 자바와 동일하게 **필드 숨김(hiding)** 이 발생함

## 💡 핵심 요약: open val vs val
| 선언 방식   | 디스패치 방식     | 오버라이딩 가능 여부           |
|-------------|------------------|-------------------------------|
| open val    | 동적 디스패치     | 자식 클래스에서 override 가능   |
| val         | 정적 디스패치     | override 불가 (숨김만 가능)     |

---

## 이 코드 이해가 매우 중요함

이 코드는 Kotlin의 open val 프로퍼티가 getter를 통해 동적 디스패치된다는 특징을 아주 잘 보여주는 예제.  
하나씩 해석해볼게요.

## 🔍 코드 구조 요약
```kotlin
open class Parent {
    open val message: String = "Parent"
    fun getParentMessage(): String = message
}

class Child : Parent() {
    override val message: String = "Child"
    fun getChildMessage(): String = message
}
```

- message는 open val → 자식 클래스에서 override 가능
- getParentMessage()는 부모 클래스에 정의된 함수지만, 내부에서 message를 참조함
- message는 `getter`를 통해 동작하므로, `동적 디스패치` 가 적용됨

## ✅ 실행 결과
```kotlin
val child = Child()

println(child.getParentMessage()) // 출력: "Child"
println(child.getChildMessage())  // 출력: "Child"
```

### 왜 둘 다 "Child"가 출력될까?
- child.getParentMessage()는 부모 클래스의 함수지만, 내부에서 message를 참조할 때 getter가 호출됨
- message는 open val이므로, 자식 클래스에서 override된 getter가 호출됨
- 따라서 런타임에 실제 객체 타입이 Child이므로 → "Child"가 출력됨

## 💡 핵심 해석
| 개념               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| open val           | getter를 오버라이드할 수 있어 동적 디스패치가 적용됨               |
| getParentMessage() | 부모 클래스의 함수지만 getter를 호출하므로 자식의 값이 반환됨       |
| 출력 결과          | "Child" → 실제 객체 타입이 Child이므로 자식의 getter가 호출됨       |



## ⚠️ 만약 message가 open이 아니었다면?
```kotlin
open class Parent {
    val message: String = "Parent" // ❌ open 없음
    fun getParentMessage() = message
}

class Child : Parent() {
    val message: String = "Child" // 숨김(hiding)
    fun getChildMessage() = message
}
```

- 이 경우 getParentMessage()는 부모의 필드를 직접 참조 → "Parent" 출력
- getChildMessage()는 자식의 필드 참조 → "Child" 출력
- 즉, 정적 디스패치가 적용됨

## ✅ 결론
- Kotlin에서 open val은 getter를 오버라이드할 수 있게 해주는 문법
- getter는 메서드이므로 동적 디스패치가 적용됨
- 따라서 부모 함수에서 접근해도 자식의 값이 출력됨


## 🔍 Kotlin의 open val은 실제로 뭐가 오버라이드되는가?
```kotlin
open class Parent {
    open val message: String
        get() = "Parent"
}

class Child : Parent() {
    override val message: String
        get() = "Child"
}
```

- 여기서 message라는 프로퍼티 이름은 같지만, 실제로 오버라이드되는 건 getter 함수
- Kotlin의 val은 필드 + getter로 구성되며, open은 getter를 열어주는 것이지 필드 자체를 오버라이드하는 게 아님

## ✅ 개념 | Kotlin에서의 의미
| 개념                   | Kotlin에서의 의미                                      |
|------------------------|--------------------------------------------------------|
| val                   | 변경 불가능한 프로퍼티 (필드 + getter)                  |
| open val              | getter를 오버라이드 가능하게 열어줌                     |
| 오버라이드 대상         | 필드가 아니라 getter 함수                              |
| 디스패치 방식           | getter는 동적 디스패치 → 자식의 값이 호출됨             |
| 필드 자체 오버라이드 여부 | ❌ 불가 (숨김만 가능, 정적 디스패치)                     |

---

# 🔍 C++에서 오버라이딩 관련 핵심 요약
| 항목             | 설명                                           |
|------------------|------------------------------------------------|
| 필드(멤버 변수)   | 오버라이딩 불가 (숨김만 가능, 정적 디스패치)         |
| 메서드           | `virtual` 키워드로 오버라이딩 가능 (동적 디스패치)   |
| getter 구현 방식 | 프로퍼티 개념 없음 → `virtual` 메서드로 직접 구현    |
| 업캐스팅 후 결과 | `virtual` 메서드면 자식의 구현 호출됨                |
| override 키워드  | C++11부터 지원 → 오버라이딩 명시 가능                |

## 🧪 예제: 메서드 오버라이딩
```cpp
class Parent {
public:
    virtual std::string getMessage() const {
        return "Parent";
    }
};

class Child : public Parent {
public:
    std::string getMessage() const override {
        return "Child";
    }
};

int main() {
    Parent* obj = new Child();
    std::cout << obj->getMessage(); // 출력: "Child"
}
```

- virtual을 붙이면 동적 디스패치가 적용되어 자식의 메서드가 호출됨
- override는 선택 사항이지만, C++11 이후로는 명시적으로 붙이는 것이 권장됨

## ⚠️ 필드(변수)는 어떻게 될까?
```cpp
class Parent {
public:
    std::string message = "Parent";
};

class Child : public Parent {
public:
    std::string message = "Child";
};

int main() {
    Parent* obj = new Child();
    std::cout << obj->message; // 출력: "Parent"
}
```

- 필드는 정적 디스패치 → 부모 타입으로 접근하면 부모의 값 사용됨
- 자식에서 같은 이름으로 선언하면 **숨김(hiding)** 만 발생함


## ✅ 핵심 요약: C++ vs Kotlin vs Java vs C#
| 언어     | 필드 override | 프로퍼티 override 방식     | 디스패치 방식       | 오버라이딩 키워드       | 특징 요약                          |
|----------|----------------|----------------------------|----------------------|--------------------------|-------------------------------------|
| C++      | 불가 (숨김만 가능) | virtual 메서드로 getter 구현 | 메서드만 동적 디스패치 | virtual / override       | 프로퍼티 개념 없음, 메서드 기반 설계 |
| Kotlin   | 불가 (숨김만 가능) | open val → getter override | getter는 동적 디스패치 | open / override          | 프로퍼티도 메서드처럼 override 가능 |
| Java     | 불가 (숨김만 가능) | getter 메서드 override      | 메서드만 동적 디스패치 | @Override                | 필드는 숨김, getter로 다형성 구현    |
| C#       | 불가 (숨김만 가능) | virtual 프로퍼티 지원       | 프로퍼티도 동적 디스패치 | virtual / override       | 프로퍼티 자체를 override 가능        |


---


## ✅ message 프로퍼티 정의 예제 (get + set 포함)
```kotlin
open class Parent {
    open var message: String = "Parent"
        get() {
            println("Parent getter 호출됨")
            return field
        }
        set(value) {
            println("Parent setter 호출됨: $value")
            field = value
        }
}

class Child : Parent() {
    override var message: String = "Child"
        get() {
            println("Child getter 호출됨")
            return field
        }
        set(value) {
            println("Child setter 호출됨: $value")
            field = value
        }
}
```


## 🔍 사용 예시
```kotlin
fun main() {
    val child = Child()

    println(child.message)      // Child getter 호출됨 → "Child"
    child.message = "Updated"   // Child setter 호출됨 → message 변경됨

    val parent: Parent = child
    println(parent.message)     // Child getter 호출됨 → "Updated"
    parent.message = "Again"    // Child setter 호출됨 → message 변경됨
}
```

## 💡 핵심 포인트
- var을 사용하면 get과 set 모두 오버라이딩 가능
- open을 붙여야 자식 클래스에서 override 가능
- field는 Kotlin의 **백킹 필드(backing field)** 로, 실제 값을 저장하는 내부 변수
- 부모 타입으로 접근해도 getter/setter는 동적 디스패치 → 자식의 구현이 호출됨

---

# override 주의 사항
Kotlin의 프로퍼티가 단순한 변수처럼 보여도 실제로는 메서드처럼 동작한다는 것,  
그리고 getter를 명시적으로 override해야 진짜 다형성이 적용됨

## 🔍 예시 비교
```kotlin
// ❌ 필드 기반 override (정적 디스패치 위험)
override val message: String = "Child"

// ✅ 명시적 getter override (동적 디스패치 보장)
override val message: String
    get() = "Child"
```

## 💡 핵심 요약: Kotlin 프로퍼티 오버라이딩
| 항목                     | 설명                                                             | 디스패치 방식       | 추천 전략                     |
|--------------------------|------------------------------------------------------------------|----------------------|-------------------------------|
| val                      | 읽기 전용 프로퍼티 (getter만 생성됨)                              | 정적 디스패치         | 숨김만 가능, override 불가     |
| open val                 | getter 오버라이드 가능 → 다형성 적용 가능                         | 동적 디스패치         | getter 명시적 override 권장     |
| 필드 초기화              | 생성자 시점에 결정됨 → 부모 타입으로 접근 시 부모 값 사용됨         | 정적 디스패치         | 커스텀 getter로 제어 가능       |
| getter 명시적 override   | 호출 시점에 자식 구현 실행됨 → 다형성 보장                         | 동적 디스패치         | ✅ 가장 안전하고 명확한 방식     |

---




