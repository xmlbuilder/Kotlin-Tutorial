# 예외 계층화

# 📦 Kotlin 예외 계층화 도입 1단계
## ✅ 예외 클래스 선언
```kotlin
open class NetworkClientExceptionV3(message: String) : Exception(message)

class ConnectExceptionV3(val address: String, message: String) :
    NetworkClientExceptionV3(message)

class SendExceptionV3(val sendData: String, message: String) :
    NetworkClientExceptionV3(message)
```

- open 키워드로 상속 가능하게 선언
- 각 자식 클래스는 고유 필드 포함 (address, sendData)

## ✅ 예외 클래스 계층 구조 요약
| 클래스명                  | 설명 및 고유 필드                         |
|---------------------------|-------------------------------------------|
| `NetworkClientExceptionV3` | 모든 네트워크 예외의 부모 클래스           |
| `ConnectExceptionV3`       | 연결 실패 예외. 연결 주소 `address` 포함     |
| `SendExceptionV3`          | 전송 실패 예외. 전송 데이터 `sendData` 포함  |

## ✅ 예외 발생 및 처리 흐름
### Client 클래스
```kotlin
class NetworkClientV3(private val address: String) {
    var connectError = false
    var sendError = false

    fun connect() {
        if (connectError) throw ConnectExceptionV3(address, "$address 서버 연결 실패")
        println("$address 서버 연결 성공")
    }

    fun send(data: String) {
        if (sendError) throw SendExceptionV3(data, "$address 서버에 데이터 전송 실패: $data")
        println("$address 서버에 데이터 전송: $data")
    }

    fun disconnect() {
        println("$address 서버 연결 해제")
    }

    fun initError(data: String) {
        connectError = "error1" in data
        sendError = "error2" in data
    }
}
```
### Service 처리 예시
```kotlin
try {
    client.connect()
    client.send(data)
} catch (e: ConnectExceptionV3) {
    println("[연결 오류] 주소: ${e.address}, 메시지: ${e.message}")
} catch (e: SendExceptionV3) {
    println("[전송 오류] 전송 데이터: ${e.sendData}, 메시지: ${e.message}")
} finally {
    client.disconnect()
}
```

- 예외 타입별로 분리된 catch 처리
- finally로 자원 정리 보장

## ✅ 실행 결과 요약
| 입력값   | 발생 예외 또는 처리 흐름                     |
|----------|-----------------------------------------------|
| `hello`  | 연결 성공 → 전송 성공 → 연결 해제 → 정상 종료 |
| `error1` | `ConnectExceptionV3` 발생 → 연결 오류 메시지 출력 → 연결 해제 |
| `error2` | `SendExceptionV3` 발생 → 전송 오류 메시지 출력 → 연결 해제   |
| `exit`   | 루프 종료 또는 종료 명령 → 프로그램 정상 종료 |


## 📦 Kotlin 예외 계층화 도입 2단계
### ✅ 예외 처리 전략
```kotlin
try {
    client.connect()
    client.send(data)
} catch (e: ConnectExceptionV3) {
    println("[연결 오류] 주소: ${e.address}, 메시지: ${e.message}")
} catch (e: NetworkClientExceptionV3) {
    println("[네트워크 오류] 메시지: ${e.message}")
} catch (e: Exception) {
    println("[알 수 없는 오류] 메시지: ${e.message}")
} finally {
    client.disconnect()
}
```

- 자식 → 부모 → 최상위 순서로 catch 구성
- 예외 흐름이 명확하고 유지보수 용이

## ✅ 핵심 효과 요약
| 항목                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 예외별 세분화 처리 가능    | 예외 종류에 따라 맞춤형 메시지와 로직을 적용할 수 있음                |
| 공통 예외 묶음 처리 가능   | 부모 예외를 통해 여러 자식 예외를 한 번에 처리 가능                   |
| 예외 흐름 가독성 향상      | catch 블록을 계층적으로 구성해 흐름이 명확하고 읽기 쉬움              |
| 유지보수성과 확장성 증가   | 새로운 예외 추가 시 구조 변경 없이 catch 블록만 확장하면 됨           |
| 자원 정리 보장             | `finally` 또는 `use`를 통해 예외 발생 여부와 관계없이 자원 해제 가능   |

--

# 🧠 실무 예외 처리 방안 1단계

## ✅ 핵심 문제 요약
| 문제 항목               | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 복구 불가능한 예외        | 시스템 오류 등은 잡아도 해결되지 않음 → 로깅 후 사용자 알림만 처리         |
| 예외 전파의 확산          | 예외를 계속 던지면 상위 계층까지 복잡하게 연결됨                         |
| `throws`의 번거로움       | Kotlin은 `throws`를 강제하지 않지만, Java 연동 시 여전히 고려 필요         |
| `Exception` 남용 위험     | 모든 예외를 `Exception`으로 처리하면 중요한 예외를 놓칠 수 있음            |

## ✅ Kotlin 예외 처리 전략 제안
- 복구 불가능한 예외는 로깅 후 사용자에게 오류 메시지 제공
- 복구 가능한 예외만 선택적으로 처리
- 공통 예외 핸들러 또는 runCatching으로 흐름 제어
- 예외 래핑으로 전파 구조 단순화

---

# Kotlin 장점 살리기

자바 기반 예외 계층화 구조를 진짜 Kotlin 방식으로 재설계해보면  
다음과 같은 방향이 가장 자연스럽고 실무에 적합:

## ✅ Kotlin 예외 처리 방식 제안
### 1. 예외 계층은 그대로 유지하되 sealed class로 구조화
```kotlin
sealed class NetworkClientExceptionV3(message: String) : Exception(message)

class ConnectExceptionV3(val address: String, message: String) :
    NetworkClientExceptionV3(message)

class SendExceptionV3(val sendData: String, message: String) :
    NetworkClientExceptionV3(message)
```
- sealed class를 사용하면 예외 타입을 제한된 범위로 관리 가능
- when 표현식에서 스마트 캐스팅 가능

### 2. 자원 정리는 use 또는 finally로 안전하게 처리
```kotlin
try {
    client.connect()
    client.send(data)
} catch (e: NetworkClientExceptionV3) {
    when (e) {
        is ConnectExceptionV3 -> println("[연결 오류] 주소: ${e.address}, 메시지: ${e.message}")
        is SendExceptionV3 -> println("[전송 오류] 데이터: ${e.sendData}, 메시지: ${e.message}")
    }
} catch (e: Exception) {
    println("[알 수 없는 오류] ${e.message}")
} finally {
    client.disconnect()
}
```
- `when` 을 통해 sealed 예외 타입별 분기 처리
- `finally` 로 자원 정리 보장

###  3. 함수형 스타일로 runCatching 적용
```kotlin
runCatching {
    client.connect()
    client.send(data)
}.onFailure { e ->
    when (e) {
        is ConnectExceptionV3 -> println("[연결 오류] 주소: ${e.address}, 메시지: ${e.message}")
        is SendExceptionV3 -> println("[전송 오류] 데이터: ${e.sendData}, 메시지: ${e.message}")
        else -> println("[알 수 없는 오류] ${e.message}")
    }
}.also {
    client.disconnect()
}

```

- 예외를 `Result` 로 감싸서 흐름 제어
- `onFailure` 에서 타입별 처리 가능
- `also` 로 자원 정리

## 4. 고급 구조: 공통 핸들러 함수로 분리
```kotlin
fun handleException(e: Throwable) {
    when (e) {
        is ConnectExceptionV3 -> println("[연결 오류] 주소: ${e.address}, 메시지: ${e.message}")
        is SendExceptionV3 -> println("[전송 오류] 데이터: ${e.sendData}, 메시지: ${e.message}")
        else -> println("[알 수 없는 오류] ${e.message}")
    }
}

runCatching {
    client.connect()
    client.send(data)
}.onFailure(::handleException)
  .also { client.disconnect() }

```

- 예외 처리 로직을 함수로 분리 → 테스트 및 재사용 용이

## 💡 Kotlin 방식 핵심 요약
| 항목               | Kotlin 방식 설명                                                              |
|--------------------|-------------------------------------------------------------------------------|
| `sealed class`     | 예외 타입을 제한된 계층으로 관리 → `when`에서 스마트 캐스팅 가능               |
| `try-catch-finally`, `runCatching` | 명시적 예외 처리 또는 함수형 스타일 처리 가능 (`Result` 기반)         |
| `finally`, `use`   | 자원 정리를 안전하게 보장 (`Closeable` 자원은 `use`로 자동 정리)               |
| `when`             | 예외 타입별 분기 처리 → 가독성 높고 유지보수 용이                             |
| `handleException`  | 공통 예외 처리 로직을 함수로 분리 → 재사용성과 테스트 용이                     |

---

## ✅ 실무 예외 처리 방안 2단계

### 📌 핵심 전략 요약
| 전략 요소                         | Kotlin 방식 설명                                                              |
|----------------------------------|-------------------------------------------------------------------------------|
| `RuntimeException` + `throws` 생략 | 복구 불가능한 예외는 언체크 예외로 선언 → `throws` 없이 간결하게 처리 가능       |
| `catch`                           | 복구 가능한 예외만 선택적으로 처리 → 나머지는 공통 핸들러로 위임                |
| `catch(Exception)` 또는 `runCatching.onFailure` | 최상위에서 모든 예외를 포괄 처리 → 사용자 메시지 + 개발자 로그 출력 가능         |
| `handleException()`              | 공통 예외 처리 함수 → 예외 객체를 받아 메시지 출력 및 로깅 수행                  |
| `when`                           | 예외 타입별 분기 처리 → 추가 정보 출력 및 세분화된 로깅 가능                     |


### ✅ 예외 클래스 정의
```kotlin
sealed class NetworkClientExceptionV4(message: String) : RuntimeException(message)

class ConnectExceptionV4(val address: String, message: String) : NetworkClientExceptionV4(message)

class SendExceptionV4(val sendData: String, message: String) : NetworkClientExceptionV4(message)
```

### ✅ 공통 예외 처리 함수
```kotlin
fun handleException(e: Throwable) {
    println("사용자 메시지: 죄송합니다. 알 수 없는 문제가 발생했습니다.")
    println("==개발자용 디버깅 메시지==")
    e.printStackTrace()

    when (e) {
        is SendExceptionV4 -> println("[전송 오류] 전송 데이터: ${e.sendData}")
        is ConnectExceptionV4 -> println("[연결 오류] 주소: ${e.address}")
    }
}
```


### ✅ Main 흐름 예시
```kotlin
fun main() {
    val service = NetworkServiceV4()
    while (true) {
        print("전송할 문자: ")
        val input = readln()
        if (input == "exit") break

        runCatching {
            service.sendMessage(input)
        }.onFailure(::handleException)

        println()
    }
    println("프로그램을 정상 종료합니다.")
}
```


## ✅ Kotlin의 Try-with-resources: use 확장 함수

### 📌 핵심 개념
- Kotlin은 `AutoCloseable` 대신 `Closeable` 을 구현하고 `use` 확장 함수로 자원 자동 정리
- `use` 는 `finally` 없이도 자원 해제를 보장

### ✅ 자원 클래스 정의
```kotlin
class NetworkClientV5(private val address: String) : Closeable {
    var connectError = false
    var sendError = false

    fun connect() {
        if (connectError) throw ConnectExceptionV4(address, "$address 서버 연결 실패")
        println("$address 서버 연결 성공")
    }

    fun send(data: String) {
        if (sendError) throw SendExceptionV4(data, "$address 서버에 데이터 전송 실패: $data")
        println("$address 서버에 데이터 전송: $data")
    }

    fun initError(data: String) {
        connectError = "error1" in data
        sendError = "error2" in data
    }

    override fun close() {
        println("NetworkClientV5.close")
        println("$address 서버 연결 해제")
    }
}
```

### ✅ 서비스 클래스
```kotlin
class NetworkServiceV5 {
    fun sendMessage(data: String) {
        val address = "https://example.com"
        NetworkClientV5(address).use { client ->
            client.initError(data)
            client.connect()
            client.send(data)
        }
    }
}
```

## 💡 실행 흐름 예시
| 입력값   | 흐름 설명                                 |
|----------|--------------------------------------------|
| `hello`  | 연결 성공 → 전송 성공 → `use` 종료 → `close()` 호출 |
| `error1` | 연결 실패 → 예외 발생 → `close()` 호출             |
| `error2` | 전송 실패 → 예외 발생 → `close()` 호출             |
| `exit`   | 루프 종료 → 프로그램 정상 종료                    |


## ✨ Kotlin use 방식의 장점
| 요소        | 설명                                                                 |
|-------------|----------------------------------------------------------------------|
| `close()`   | 자원 해제를 자동으로 보장 → 누락 방지, 안정성 향상                     |
| `finally`   | 명시적으로 작성하지 않아도 자원 정리 가능 → 코드 간결성 증가           |
| `use`       | 자원 사용 범위가 명확히 제한됨 → 유지보수 용이, 스코프 관리 쉬움        |
| 예외 흐름   | 예외 발생 시에도 자원 정리 보장 → 예외 흐름과 자원 관리가 분리되어 깔끔함 |


## ✅ 결론
- Kotlin에서는 `Closeable + use` 로 자원 정리를 자동화
- `runCatching + handleException` 으로 공통 예외 처리 구조 구현 가능
- 예외 계층화 + 함수형 흐름 제어 + 자원 자동 정리 → 실무에서 매우 효과적인 패턴

----

# 참조 함수 기법

## ✅ onFailure(::handleException)란?
### 🔹 전체 구조
```kotlin
runCatching {
    // 예외 발생 가능 코드
}.onFailure(::handleException)
```

### 🔹 의미
- `runCatching` { ... } → 예외 발생 가능 코드를 실행하고 Result 객체로 감쌈
- `onFailure` { ... } → 실패했을 때 실행할 로직 지정
- ::handleException → handleException(e: Throwable) 함수에 대한 함수 참조  
    즉, `onFailure(::handleException)` 는 예외가 발생했을 때 handleException() 함수를 자동으로 호출하는 구조입니다.

## ✅ 함수 참조란?
| 표현 방식              | 설명                                                             |
|------------------------|------------------------------------------------------------------|
| `::함수명`             | 함수 자체를 참조하는 표현 → 다른 함수에 인자로 넘길 수 있음         |
| `onFailure(::함수명)`  | 실패 시 해당 함수를 자동 호출 → `Throwable`을 인자로 받는 함수 필요 |
| `val f = ::함수명`     | 함수 참조를 변수에 저장 → 나중에 `f()`처럼 호출 가능                |


### 예시:
```kotlin
fun logError(e: Throwable) {
    println("에러 발생: ${e.message}")
}

val result = runCatching { riskyCode() }
result.onFailure(::logError)
```

## ✅ 장점
- ✅ 코드 간결성: 람다 대신 함수 이름만 넘겨도 됨
- ✅ 재사용성: 공통 처리 로직을 함수로 분리해 여러 곳에서 사용 가능
- ✅ 가독성 향상: 예외 처리 흐름이 명확하게 드러남

---

# use

## ✅ 이 코드는 람다입니다
```kotlin
NetworkClientV5(address).use { client ->
    client.initError(data)
    client.connect()
    client.send(data)
}
```

- `use { client -> ... }` 는 `Closeable` 을 구현한 객체에 대해 람다 블록을 실행하는 구조
- client는 NetworkClientV5(address)의 인스턴스를 use가 람다의 인자로 넘겨준 것
- 즉, `client` 는 자동 생성된 게 아니라 `use` 가 넘겨준 `람다 파라미터`

## ✅ use 확장 함수의 정의
```kotlin
inline fun <T : Closeable?, R> T.use(block: (T) -> R): R
```
- block: (T) -> R → 이게 바로 람다
- use는 Closeable을 구현한 객체에 대해 block을 실행하고, 끝나면 자동으로 close() 호출

## 🔍 흐름 요약
- NetworkClientV5(address) 객체 생성
- use 확장 함수가 그 객체를 client라는 이름으로 람다에 넘김
- 람다 블록 실행: initError → connect → send
- 블록이 끝나면 client.close() 자동 호출

## 💡 핵심 포인트
| 요소       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| `use`      | `Closeable`을 구현한 객체에 대해 자원 사용 후 자동으로 `close()` 호출     |
| `client`   | `use`가 람다에 넘겨주는 인스턴스 → 명시적 파라미터로 사용됨               |
| `{ client -> ... }` | 람다 표현식 → 자원 사용 로직을 함수형 스타일로 작성 가능             |


---

# `try-with-resources` 문법은 사용하지 못함

Kotlin에서는 Java처럼 try (Resource r = ...) { ... } 형태의 try-with-resources 문법은 직접적으로 지원되지 않습니다.  
하지만 Kotlin은 그 대신 훨씬 더 간결하고 안전한 방식인 use 확장 함수를 제공합니다.

## ✅ Java 방식 vs Kotlin 방식 비교
| 언어     | 자원 자동 해제 방식                                      |
|----------|----------------------------------------------------------|
| Java     | `try (Resource r = ...) { ... }` → `AutoCloseable` 기반   |
| Kotlin   | `Resource().use { r -> ... }` → `Closeable` + `use` 확장 함수 |


## 🔹 Java 방식 (불가능한 Kotlin 문법)
```java
try (FileReader reader = new FileReader("file.txt")) {
    // 파일 읽기
}
```
## 🔸 Kotlin에서는 위 문법이 컴파일 오류가 납니다.

## 🔹 Kotlin 방식 (정상적인 자원 처리)
```kotlin
File("file.txt").bufferedReader().use { reader ->
    val content = reader.readText()
    println(content)
}
```
- use는 Closeable을 구현한 객체에 대해 자동으로 close() 호출
- 예외가 발생해도 자원 누수 없이 안전하게 종료됨

## 💡 핵심 요약
- Kotlin은 Java의 `try-with-resources` 를 지원하지 `않음`
- 대신 `use` 확장 함수로 더 간결하고 안전하게 자원 관리
- `use` 는 `Closeable` 을 구현한 객체에만 사용 가능

---

