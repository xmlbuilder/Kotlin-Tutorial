# 🧠 Kotlin 메모리 구조 요약
## 🎨 비유로 이해하는 Kotlin 메모리
| 메모리 영역   | 비유 설명             | 실제 역할                          |
|---------------|------------------------|-------------------------------------|
| 메서드 영역   | 붕어빵 틀              | 클래스 정보, 함수 코드, companion object 저장 |
| 스택 영역     | 붕어빵을 굽는 과정     | 함수 호출 시 스택 프레임 생성, 지역 변수 저장 |
| 힙 영역       | 완성된 붕어빵 (`()`) | 클래스 인스턴스와 배열이 생성되는 공간 |


## 🧩 실제 Kotlin 메모리 구조
### 1️⃣ 메서드 영역 (Method Area)
- 클래스의 구조 정보, 함수 정의, 생성자 정보 저장
- object, companion object, val 등 정적 요소 포함
- 런타임 상수 풀 존재
- 모든 쓰레드가 공유
### 2️⃣ 스택 영역 (Stack Area)
- 각 쓰레드마다 하나의 실행 스택 생성
- 함수 호출 시 스택 프레임 생성, 종료 시 제거
- 지역 변수, 매개변수, 연산 결과 저장
### 3️⃣ 힙 영역 (Heap Area)
- val, var로 생성된 객체가 위치
- Data(), Person() 등 클래스 인스턴스는 힙에 저장
- 가비지 컬렉션(GC)이 참조되지 않는 객체를 자동 제거

## 📌 메서드 공유 구조
- 같은 클래스로 생성된 여러 인스턴스는 함수 코드를 공유
- 인스턴스마다 프로퍼티는 독립적이지만, 함수는 메서드 영역에서 공통 실행
- 함수 호출 시, 실제로는 메서드 영역의 코드를 참조함

## 🧠 Kotlin에서의 스택과 큐 자료 구조
### 📦 Stack (스택)
- 정의: 나중에 넣은 데이터가 먼저 나오는 구조
- 동작 방식: 한쪽 끝에서만 데이터를 넣고 뺌
- 특징:
- 후입 선출 (LIFO)
- 함수 호출, 실행 흐름 관리에 적합
#### 🔁 예시 흐름
```
1(넣기) → 2(넣기) → 3(넣기) → 3(빼기) → 2(빼기) → 1(빼기)
```

### 📦 Queue (큐)
- 정의: 먼저 넣은 데이터가 먼저 나오는 구조
- 동작 방식: 뒤에서 넣고 앞에서 뺌
- 특징:
- 선입 선출 (FIFO)
- 대기열, 이벤트 처리 등에 적합
#### 🔁 예시 흐름
```
1(넣기) → 2(넣기) → 3(넣기) → 1(빼기) → 2(빼기) → 3(빼기)
```
## 🧩 스택 vs 큐 비교 표
| 자료 구조 | 특징        | 동작 방식             | 예시 흐름                                 | 활용 예시                     |
|-----------|-------------|------------------------|--------------------------------------------|-------------------------------|
| 스택      | 후입 선출   | 위에서 넣고 위에서 뺌   | 1 → 2 → 3 → 3 → 2 → 1                      | 함수 호출, 실행 흐름 관리     |
| 큐        | 선입 선출   | 뒤에서 넣고 앞에서 뺌   | 1 → 2 → 3 → 1 → 2 → 3   


## 💡 Kotlin과의 연결
- Kotlin도 JVM 위에서 동작하므로 함수 호출 시 스택 프레임이 생성됨
- 지역 변수와 매개변수는 해당 스택 프레임에 저장됨
- 함수가 종료되면 스택 프레임과 변수는 제거됨


---

## 🧠 Kotlin에서 static 변수의 필요성
Kotlin에는 `static` 키워드가 없고, 대신 `companion object` 를 사용해 클래스 수준 공유를 구현합니다.

###  1️⃣ 인스턴스 변수로 카운트 저장 (잘못된 방식)
```kotlin
class Data1(val name: String) {
    var count: Int = 0

    init {
        count++ // ❌ 모든 인스턴스가 독립된 count를 가짐
    }
}
```

- 각 객체마다 count가 따로 존재 → 공유 불가
- 객체 수를 정확히 세지 못함

### 2️⃣ 외부 객체로 카운트 저장 (Counter 클래스 활용)
```kotlin
class Counter {
    var count: Int = 0
}

class Data2(val name: String, counter: Counter) {
    init {
        counter.count++ // ✅ 모든 인스턴스가 같은 Counter를 참조
    }
}
```

- 정확한 카운팅 가능하지만 구조가 복잡해짐
- 생성자 매개변수가 늘어남

### 3️⃣ Kotlin의 해결책: `companion object` 사용
```kotlin
class Data3(val name: String) {
    companion object {
        var count: Int = 0
    }

    init {
        count++ // ✅ 클래스 수준에서 공유됨
    }
}
```

#### 🧪 코드 흐름 요약
```kotlin
val data1 = Data3("A") // count = 1  
val data2 = Data3("B") // count = 2  
val data3 = Data3("C") // count = 3  
println(Data3.count)   // 출력: 3
```

- count는 클래스 전체에서 공유됨
- Data3.count로 직접 접근 가능

## 📦 Kotlin 멤버 변수 종류
| 변수 종류       | companion object 여부 | 저장 위치     | 접근 방식               | 생명주기                      | 특징 설명                             |
|----------------|------------------------|----------------|--------------------------|-------------------------------|----------------------------------------|
| 인스턴스 변수   | ❌ 없음                 | 힙 영역         | 인스턴스를 통해 접근     | 객체 생성 ~ GC 제거 시까지     | 객체마다 독립적으로 존재               |
| 클래스 변수     | ✅ 있음                 | 메서드 영역     | 클래스명으로 접근        | 클래스 로딩 ~ JVM 종료 시까지 | 모든 인스턴스가 하나의 값을 공유       |
| 지역 변수       | 해당 없음              | 스택 영역       | 함수 내부에서만 접근     | 함수 호출 시 ~ 종료 시까지    | 함수 실행 중에만 존재, 외부 접근 불가 |



## ⏳ 변수 생명주기
| 변수 종류       | 저장 위치     | 생성 시점             | 제거 시점                  | 특징 설명                                 |
|----------------|----------------|------------------------|-----------------------------|--------------------------------------------|
| 지역 변수       | 스택 영역       | 함수 호출 시           | 함수 종료 시                | 함수 실행 중에만 존재, 외부 접근 불가       |
| 인스턴스 변수   | 힙 영역         | 객체 생성 시           | GC(가비지 컬렉션) 발생 시   | 객체마다 독립적으로 존재, 참조값으로 접근   |
| 클래스 변수     | 메서드 영역     | 클래스 로딩 시         | JVM 종료 시                 | `companion object` 내부에 선언, 클래스 전체 공유 |
| 전역 변수       | 없음 (Kotlin은 지원하지 않음) | -                      | -                           | Kotlin은 명시적 전역 변수 개념 없음         |



## 🧩 접근 방식 비교
```kotlin
val data4 = Data3("D")
println(data4.count)     // 인스턴스를 통한 접근 (비추천)
println(Data3.count)     // 클래스를 통한 접근 (추천)
```

- 둘 다 같은 변수에 접근하지만, 클래스명을 통한 접근이 더 명확하고 안전함

## 🧠 Kotlin에서 static 메서드
Kotlin에서는 static 메서드 대신 companion object 안에 함수를 정의합니다.
📌 개념 비교
| 항목             | 인스턴스 메서드                          | companion object 메서드 (정적 메서드 역할) |
|------------------|------------------------------------------|---------------------------------------------|
| 선언 방식        | `fun greet(name: String)`                | `fun greet(name: String)` inside companion  |
| 호출 방식        | `Data3().greet("A")`                     | `Data3.greet("A")`                           |
| 객체 필요 여부   | ✅ 필요                                   | ❌ 불필요                                     |
| 사용 목적        | 인스턴스 상태를 활용할 때                | 공용 기능 제공, 유틸리티 함수 등             |



## 🧠 Kotlin에서의 정적 메서드와 변수
### 📌 Kotlin의 static 대체 구조
| 자바 개념       | Kotlin 대응 방식         | 설명                                       |
|----------------|--------------------------|--------------------------------------------|
| static 변수     | companion object         | 클래스 수준에서 공유되는 변수 정의 가능     |
| static 메서드   | companion object         | 클래스명으로 직접 호출 가능한 함수 정의     |
| 유틸리티 클래스 | object                   | 싱글톤 객체로 인스턴스 없이 사용 가능       |
| private 생성자  | object 또는 private constructor | 인스턴스 생성을 막아 유틸리티 전용으로 사용 |

## 1️⃣ 인스턴스 vs 정적 메서드
### Instance 메소드
```kotlin
class DecoUtil1 {
    fun deco(str: String): String {
        return "*$str*"
    }
}
```
### 클래스 메소드
```kotlin
class DecoUtil2 {
    companion object {
        fun deco(str: String): String {
            return "*$str*"
        }
    }
}
```


### 호출 방식
```kotlin
val utils = DecoUtil1()
val result1 = utils.deco("hello kotlin") // 인스턴스 메서드
val result2 = DecoUtil2.deco("hello kotlin") // 정적 메서드
```

- DecoUtil2.deco()는 객체 없이 호출 가능 → 효율적

## 2️⃣ companion object의 접근 제한
```kotlin
class DecoData {
    private var instanceValue = 0
    companion object {
        private var staticValue = 0
        fun staticCall() {
            staticValue++
            staticMethod()
            // instanceValue++ ❌ 불가능
            // instanceMethod() ❌ 불가능
        }

        private fun staticMethod() {
            println("staticValue=$staticValue")
        }
    }

    fun instanceCall() {
        instanceValue++
        instanceMethod()
        staticValue++
        staticMethod()
    }

    private fun instanceMethod() {
        println("instanceValue=$instanceValue")
    }
}
```

- companion object 내부에서는 인스턴스 기능 사용 불가
- 인스턴스 기능은 클래스 외부에서 객체를 통해 접근해야 함

## ✅ 예외: 참조값 전달
companion object {
    fun staticCall(data: DecoData) {
        data.instanceCall() // ✅ 객체 참조를 통해 인스턴스 기능 사용 가능
    }
}



## 3️⃣ main()과 정적 메서드
```kotlin
fun main() {
    val valueData = ValueData()
    add(valueData)
}

fun add(valueData: ValueData) {
    valueData.value++
    println("숫자 증가 value=${valueData.value}")
}

class ValueData(var value: Int = 0)
```

- main()은 Kotlin에서 fun main()으로 정의되며, 객체 없이 실행됨
- 내부에서 호출하는 함수도 정적처럼 동작해야 함

## 4️⃣ Kotlin 유틸리티 클래스
### 자바 스타일 변환
```kotlin
object MathArrayUtils {
    fun sum(array: IntArray): Int = array.sum()

    fun average(array: IntArray): Double = array.average()

    fun min(array: IntArray): Int = array.minOrNull() ?: 0

    fun max(array: IntArray): Int = array.maxOrNull() ?: 0
}
```

### 사용 예
```
val arr = intArrayOf(1, 2, 3, 4, 5)
println("sum=${MathArrayUtils.sum(arr)}")
println("average=${MathArrayUtils.average(arr)}")
println("min=${MathArrayUtils.min(arr)}")
println("max=${MathArrayUtils.max(arr)}")
```

- object 선언으로 인스턴스 생성 없이 바로 사용 가능
- 생성자도 없으므로 실수로 생성할 위험 없음

## 5️⃣ 차량 수 카운트 예제
```kotlin
class Car(val name: String) {
    companion object {
        private var totalCars = 0

        fun showTotalCars() {
            println("구매한 차량 수: $totalCars")
        }
    }

    init {
        println("차량 구입, 이름: $name")
        totalCars++
    }
}
```

### 사용 예
```kotlin
val car1 = Car("K3")
val car2 = Car("G80")
val car3 = Car("Model Y")
Car.showTotalCars()
```

- totalCars는 클래스 전체에서 공유됨
- showTotalCars()는 객체 없이 호출 가능

## ✅ 핵심 요약
| 개념/용도           | Kotlin 방식           | 설명                                       |
|---------------------|------------------------|--------------------------------------------|
| 클래스 수준 변수     | companion object       | 클래스 전체에서 공유되는 변수 정의 가능     |
| 클래스 수준 함수     | companion object       | 객체 없이 클래스명으로 직접 호출 가능       |
| 유틸리티 클래스      | object                 | 싱글톤 객체로 인스턴스 없이 사용 가능       |
| 인스턴스 생성 방지   | private constructor    | 외부에서 객체 생성 못하도록 차단            |
| 자바 static 대체     | companion object / object | Kotlin은 static 키워드 없이 객체 지향적으로 구현 |


----

# 문자열 출력 

## 🔍 예시
```kotlin
fun decorate(str: String): String {
    return "*$str*"
}
```

### 호출 예
```kotlin
val result = decorate("Kotlin")
println(result) // 출력: *Kotlin*
```

- $str은 변수 str의 값을 문자열 안에 삽입하는 표현
- *는 그냥 문자열로 붙는 거라서 결과적으로 *Kotlin*처럼 출력됨

## 💡 보간 확장
- ${}를 사용하면 더 복잡한 표현도 가능:
```kotlin
val name = "JungHwan"
val greeting = "Hello, ${name.uppercase()}!"
println(greeting) // 출력: Hello, JUNGHWAN!
```

---

# 🧠 왜 companion object가 따로 필요할까?
## 1️⃣ 객체 지향 철학을 유지하기 위해
- Kotlin은 모든 것이 객체라는 철학을 따름
- 자바의 static은 클래스에 소속된 "비객체적" 요소지만, Kotlin은 이를 객체로 감싸서 처리함
- 그래서 companion object는 클래스 내부에 존재하지만, 하나의 객체로 취급됨
```kotlin
class MyClass {
    companion object {
        fun greet() = "Hello"
    }
}
```

- MyClass.greet()처럼 호출되지만, 내부적으로는 MyClass.Companion.greet()라는 객체 호출이에요



## 🧠 Kotlin의 top-level 함수란?
- 클래스나 객체에 속하지 않고 파일 최상단에 직접 정의된 함수
- 객체 생성 없이 바로 호출 가능
- 마치 "전역 함수"처럼 보이지만, 실제로는 파일 스코프에 속한 함수
```kotlin
// HelloUtils.kt
fun sayHello(name: String): String {
    return "Hello, $name!"
}

// 다른 파일에서
val greeting = sayHello("JungHwan") // ✅ 클래스 없이 바로 호출
```

## 🔍 자바와 Kotlin 함수 호출 방식 비교
| 항목             | 자바 방식                          | Kotlin 방식                          | 설명                                       |
|------------------|------------------------------------|--------------------------------------|--------------------------------------------|
| 함수 위치         | 클래스 내부                        | 클래스 내부 또는 파일 최상단(top-level) | Kotlin은 클래스 없이도 함수 정의 가능       |
| 정적 함수 선언    | `static` 키워드 필요               | `companion object` 또는 `object` 사용 | Kotlin은 객체 기반으로 정적 개념 구현       |
| 호출 방식         | `ClassName.method()`              | `ClassName.method()` 또는 `method()` | Kotlin은 클래스 없이도 직접 호출 가능       |
| import 방식       | `import ClassName.method`         | `import package.method`              | Kotlin은 top-level 함수도 import 가능       |



## 💡 왜 이렇게 설계했을까?
- Kotlin은 함수형 프로그래밍 철학도 반영해서  
    → "기능 중심 코드"를 더 쉽게 작성할 수 있도록 함
- 클래스 없이도 간결하고 명확한 코드를 만들 수 있음
- 필요할 때만 객체 지향 구조를 도입할 수 있음 → 유연한 설계 가능

## ✅ 핵심 요약
- Kotlin에서는 function도 클래스 밖에 정의할 수 있음 → top-level 함수
- 자바처럼 static 키워드 없이도 클래스 없이 호출 가능
- 이는 Kotlin의 간결함 + 객체 지향 + 함수형 철학을 모두 반영한 설계

---

## 🔍 자바의 static class란?
```java
class Outer {
    static class Inner {
        void hello() { System.out.println("Hi"); }
    }
}
```
- Outer.Inner는 Outer 객체 없이도 사용 가능
- 정적 중첩 클래스(static nested class)라고 불림

## 🧠 Kotlin에서 대응 방식

## 1️⃣ object — 싱글톤 객체
```kotlin
object Logger {
    fun log(msg: String) = println(msg)
}
```

- 클래스 없이도 전역처럼 사용 가능
- 자바의 static class와는 다르지만, 인스턴스 없이 접근 가능하다는 점에서 유사
## 2️⃣ companion object — 클래스 내부 정적 공간
```kotlin
class Greeter {
    companion object {
        fun hello() = println("Hi")
    }
}
```

- Greeter.hello()처럼 호출 가능
- 자바의 static 메서드/변수와 가장 유사한 구조
## 3️⃣ class + object 조합 — 자바 static class에 가장 가까운 구조
```kotlin
class Outer {
    object Inner {
        fun hello() = println("Hi")
    }
}
```

- Outer.Inner.hello()처럼 사용 가능
- 자바의 static class Inner와 거의 같은 방식으로 동작

## ✅ 핵심 요약: Kotlin의 static 대체 구조
| 용도/개념         | Kotlin 구조           | 설명                                       |
|------------------|------------------------|--------------------------------------------|
| 전역 유틸리티     | object                 | 싱글톤 객체, 클래스 없이도 직접 접근 가능   |
| 클래스 수준 변수  | companion object       | 클래스 전체에서 공유되는 변수 정의 가능     |
| 클래스 수준 함수  | companion object       | 객체 없이 클래스명으로 직접 호출 가능       |


----

# singleton

object Logger처럼 선언하면, 그 안에 정의된 변수는 싱글톤 객체의 멤버 변수가 되기 때문에  
전역처럼 하나만 존재하는 변수처럼 사용할 수 있음.

## 🔍 예시
```rust
object Logger {
    var logCount = 0

    fun log(msg: String) {
        println(msg)
        logCount++
    }
}
```

### 사용 방식
```rust
Logger.log("Hello")       // 출력: Hello
println(Logger.logCount)  // 출력: 1
```

- Logger는 프로그램 전체에서 하나의 인스턴스만 존재
- logCount는 그 인스턴스의 멤버 변수 → 싱글톤 변수처럼 동작

## ✅ 특징 요약
| 항목            | 설명                                           |
|-----------------|------------------------------------------------|
| object          | Kotlin의 싱글톤 선언 방식, 단 하나의 인스턴스 생성 |
| 변수 접근 방식   | 클래스명처럼 `Logger.logCount`로 직접 접근 가능     |
| 인스턴스 생성    | 불가능 (자동으로 단 하나만 생성됨)               |
| 사용 목적        | 전역 유틸리티, 설정값, 상태 공유 등               |
| 생명주기         | 프로그램 시작 시 생성 → 종료 시까지 유지           |


---


