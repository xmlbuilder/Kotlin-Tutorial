# 📚 리스트 추상화와 다형성
## ✅ 핵심 개념
- List는 순서가 있고 중복을 허용하는 자료구조
- MyArrayList와 MyLinkedList는 내부 구현은 다르지만 동일한 기능을 제공
- 공통 기능을 MyList 인터페이스로 추상화하면 다형성과 OCP(Open-Closed Principle) 적용 가능

## ✅ MyList 인터페이스
```kotlin
interface MyList<E> {
    fun size(): Int
    fun add(element: E)
    fun add(index: Int, element: E)
    fun get(index: Int): E
    fun set(index: Int, element: E): E
    fun remove(index: Int): E
    fun indexOf(element: E): Int
}
````

## ✅ 구현 클래스
- MyArrayList와 MyLinkedList는 MyList를 구현
- 각 클래스는 내부 자료구조에 따라 성능 특성이 다름
- MyArrayList: 배열 기반, 앞쪽 삽입/삭제는 느림 → O(n)
- MyLinkedList: 연결 리스트 기반, 앞쪽 삽입/삭제는 빠름 → O(1)

## 🔄 의존관계 주입 (Dependency Injection)

### ✅ 문제 상황
- BatchProcessor가 MyArrayList에 직접 의존하면, MyLinkedList로 변경 시 코드 수정 필요
- 이는 OCP 위반이며 유연하지 못한 설계
- 
### ✅ 해결 방법
- BatchProcessor가 MyList 인터페이스에 의존하도록 변경
- 생성자를 통해 구현체를 주입받음 → 생성자 의존관계 주입
  
```kotlin
class BatchProcessor(private val list: MyList<Int>) {
    fun logic(size: Int) {
        repeat(size) {
            list.add(0, it) // 앞에 추가
        }
    }
}
```

### ✅ 실행 예시
```kotlin
fun main() {
    val list: MyList<Int> = MyArrayList() // 또는 MyLinkedList()
    val processor = BatchProcessor(list)
    processor.logic(50_000)
}
```

## 📊 성능 비교 결과

| 기능             | MyArrayList (배열 기반) | MyLinkedList (연결 리스트 기반) |
|------------------|--------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 1369ms         | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 651ms          | O(n) – 약 1112ms                 |
| 뒤에 추가/삭제   | O(1) – 약 2ms            | O(n) – 약 2195ms                 |
| 인덱스 조회       | O(1) – 평균 1ms          | O(n) – 평균 438ms                |
| 검색             | O(n) – 평균 115ms        | O(n) – 평균 492ms                |

- MyLinkedList는 앞쪽 삽입에 최적화되어 있어 성능이 압도적으로 우수
- 전략을 런타임에 선택할 수 있어 유연하고 확장 가능한 설계 가능

## ✅ 구조 정리 (Kotlin 버전)

| 구성 요소         | 설명                                                  |
|------------------|-------------------------------------------------------|
| `MyList`         | 리스트 기능을 추상화한 인터페이스. 전략의 기준이 되는 타입 |
| `BatchProcessor` | `MyList`에 의존하는 클라이언트. 생성자 주입 방식 사용     |
| `MyArrayList`    | 배열 기반 리스트 구현체. 앞쪽 삽입 시 O(n) 성능            |
| `MyLinkedList`   | 연결 리스트 기반 구현체. 앞쪽 삽입 시 O(1) 성능            |

### 🧠 Kotlin 예시
```kotlin
val list: MyList<Int> = MyArrayList() // 또는 MyLinkedList()
val processor = BatchProcessor(list)
processor.logic(50_000)
```

- BatchProcessor는 컴파일 타임에 MyList에만 의존
- 런타임에는 MyArrayList() 또는 MyLinkedList()가 주입됨
- 덕분에 구현체를 바꾸더라도 BatchProcessor 코드는 변경할 필요 없음 → OCP 원칙 준

---

# 🧠 리스트 추상화와 설계 원칙
## ✅ 핵심 개념
- List: 순서가 있고 중복을 허용하는 자료구조
- MyArrayList, MyLinkedList: 기능은 같지만 내부 구현이 다름
- 공통 기능을 MyList 인터페이스로 추상화 → 다형성과 OCP 원칙 적용

## 🔄 컴파일 타임 vs 런타임 의존관계

| 구분               | 의존 대상                          | 설명                                                                 |
|--------------------|------------------------------------|----------------------------------------------------------------------|
| 컴파일 타임 의존관계 | `MyList` 인터페이스                | 코드에 명시된 타입. Kotlin 컴파일러가 인식하는 정적인 의존관계         |
| 런타임 의존관계     | `MyArrayList`, `MyLinkedList` 구현체 | 실행 시점에 실제로 주입된 인스턴스에 대한 동적인 의존관계             |

- BatchProcessor는 MyList에만 의존 → 구현체 교체 시 코드 변경 없음
- 생성자를 통해 구현체를 주입 → 생성자 의존관계 주입(DI)

## 🧩 전략 패턴 적용

| 구성 요소         | 설명                                                              |
|------------------|-------------------------------------------------------------------|
| `MyList`         | 전략 인터페이스. 리스트 기능을 추상화하여 공통 API 제공             |
| `MyArrayList`    | 전략 구현체 1. 배열 기반 리스트 구현체                              |
| `MyLinkedList`   | 전략 구현체 2. 연결 리스트 기반 구현체                              |
| `BatchProcessor` | 전략을 사용하는 클라이언트. `MyList`에만 의존하여 유연성 확보         |

- 전략 패턴을 통해 알고리즘을 런타임에 교체 가능
- 클라이언트 코드 변경 없이 다양한 리스트 전략 적용 가능

## 📊 성능 비교 요약

| 기능             | MyArrayList (배열 기반)     | MyLinkedList (연결 리스트 기반) |
|------------------|------------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 1369ms             | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 651ms              | O(n) – 약 1112ms                 |
| 뒤에 추가/삭제   | O(1) – 약 2ms                | O(n) – 약 2195ms                 |
| 인덱스 조회       | O(1) – 평균 1ms              | O(n) – 평균 438ms                |
| 검색             | O(n) – 평균 115ms            | O(n) – 평균 492ms                |


## 🧠 성능 해설
- 배열 리스트: 메모리 연속 배치 → CPU 캐시 효율 높음, 조회 빠름
- 연결 리스트: 노드 분산 → 참조 변경은 빠르지만 조회/검색은 느림
- 실제 성능은 시간 복잡도 외에도 메모리 접근 방식, 캐시 최적화 등 시스템 요인에 영향 받음

## ✅ 최종 정리

| 구성 요소         | 역할 및 설명                                                   |
|------------------|----------------------------------------------------------------|
| `MyList`         | 리스트 기능을 추상화한 인터페이스. 전략의 기준이 되는 추상 타입 |
| `MyArrayList`    | 배열 기반 리스트 구현체. 빠른 조회, 느린 앞쪽 삽입               |
| `MyLinkedList`   | 연결 리스트 기반 구현체. 빠른 앞쪽 삽입, 느린 조회               |
| `BatchProcessor` | `MyList`에 의존하는 클라이언트. 생성자 주입으로 전략 선택 가능   |


## 🧠 핵심 요약
- MyList는 전략 패턴의 인터페이스 역할
- MyArrayList, MyLinkedList는 전략의 구체적인 구현
- BatchProcessor는 전략을 런타임에 주입받아 사용
- 클라이언트 코드 변경 없이 구현체 교체 가능 → OCP 원칙 준수
- 성능 요구에 따라 전략을 선택할 수 있음 → 유연하고 확장 가능한 설계

---

# 📚 ArrayList와 LinkedList 성능 비교

Kotlin에서도 리스트 구조는 자바와 유사하게 동작합니다.  
대부분의 상황에서 ArrayList가 성능상 유리하며,  
앞쪽 삽입/삭제가 빈번한 경우에만 LinkedList를 고려하는 것이 좋습니다.  

## 📘 List 인터페이스 주요 메서드

| 메서드                        | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `add(element)`               | 리스트 끝에 요소를 추가 (`MutableList`에서 사용 가능)                |
| `add(index, element)`        | 지정된 위치에 요소를 삽입 (`MutableList`에서 사용 가능)              |
| `addAll(collection)`         | 컬렉션의 모든 요소를 리스트 끝에 추가                                |
| `addAll(index, collection)`  | 컬렉션의 모든 요소를 지정된 위치에 삽입                              |
| `get(index)`                 | 지정된 위치의 요소를 반환                                            |
| `set(index, element)`        | 지정된 위치의 요소를 변경 (`MutableList`에서 사용 가능)              |
| `removeAt(index)`            | 지정된 위치의 요소를 제거 (`MutableList`에서 사용 가능)              |
| `remove(element)`            | 지정된 첫 번째 요소를 제거                                           |
| `clear()`                    | 리스트의 모든 요소를 제거                                            |
| `indexOf(element)`           | 지정된 요소의 첫 번째 인덱스를 반환                                  |
| `lastIndexOf(element)`       | 지정된 요소의 마지막 인덱스를 반환                                   |
| `contains(element)`          | 리스트가 지정된 요소를 포함하는지 여부 반환                          |
| `sort()` / `sortedBy()`      | 리스트를 정렬 (`sort()`은 제자리 정렬, `sortedBy()`는 새 리스트 반환) |
| `subList(from, to)`          | 리스트의 일부분을 반환 (`from` 이상, `to` 미만)                       |
| `size`                       | 리스트의 요소 수를 반환                                              |
| `isEmpty()`                  | 리스트가 비어있는지 여부 반환                                       |
| `iterator()`                 | 리스트의 요소에 대한 반복자를 반환                                   |
| `toTypedArray()`             | 리스트의 모든 요소를 배열로 반환                                     |


## 📊 직접 구현한 MyArrayList vs MyLinkedList 성능 비교

| 기능             | MyArrayList (배열 기반)       | MyLinkedList (단일 연결 리스트) |
|------------------|-------------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 1369ms              | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 651ms               | O(n) – 약 1112ms                 |
| 뒤에 추가/삭제   | O(1) – 약 2ms                 | O(n) – 약 2195ms                 |
| 인덱스 조회       | O(1) – 평균 1ms               | O(n) – 평균 438ms                |
| 검색             | O(n) – 평균 115ms            | O(n) – 평균 492ms                |


## 📊 Kotlin ArrayList vs LinkedList 성능 비교

| 기능             | ArrayList (배열 기반)     | LinkedList (이중 연결 리스트)    |
|------------------|----------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 106ms            | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 49ms             | O(n) – 약 1116ms                 |
| 뒤에 추가/삭제   | O(1) – 약 1ms              | O(1) – 약 2ms                    |
| 인덱스 조회       | O(1) – 평균 1ms            | O(n) – 평균 439ms                |
| 검색             | O(n) – 평균 104ms          | O(n) – 평균 473ms                |


## 🧠 성능 요약 및 실무 팁
- ArrayList는 메모리 연속 배치와 고속 복사 덕분에 조회와 평균 삽입 성능이 우수함
- LinkedList는 앞쪽 삽입/삭제에 최적화되어 있으나, 조회/검색은 느림
- Kotlin의 LinkedList는 자바처럼 이중 연결 리스트로 구현되어 있음
- 실무에서는 대부분 ArrayList를 기본으로 사용하며, 앞쪽 삽입/삭제가 많을 경우에만 LinkedList를 고려

---

## 📘 문제와 풀이 1: 배열 → 리스트 변경
###  ✅ 문제1: 배열을 리스트로 변경하기
| 자료 구조 유형 | 선언 방식                                      |
|----------------|------------------------------------------------|
| 배열           | `val students = arrayOf(90, 80, 70, 60, 50)`   |
| 리스트         | `val students = mutableListOf(90, 80, 70, 60, 50)` |


### 📘 핵심 코드 요약
```kotlin
val students = mutableListOf(90, 80, 70, 60, 50)
val total = students.sum()
val average = total.toDouble() / students.size
println("점수 총합: $total")
println("점수 평균: $average")
``` 


## ✅ 문제2: 리스트 입력과 출력

| 항목         | 설명                                      |
|--------------|-------------------------------------------|
| 입력 구조     | `MutableList<Int>` 사용                   |
| 종료 조건     | `0` 입력 시 입력 종료                     |
| 출력 형식     | `1, 2, 3, 4, 5` (마지막 쉼표 없음)         |

### 📘 핵심 코드 요약
```kotlin
val numbers = mutableListOf<Int>()
println("n개의 정수를 입력하세요 (종료 0)")
while (true) {
    val input = readln().toInt()
    if (input == 0) break
    numbers.add(input)
}
println("출력")
println(numbers.joinToString(", "))
```

## ✅ 문제3: 리스트 합계와 평균

| 항목         | 설명                                      |
|--------------|-------------------------------------------|
| 입력 구조     | `MutableList<Int>` 사용                   |
| 종료 조건     | `0` 입력 시 입력 종료                     |
| 처리 방식     | 합계 계산 후 평균 도출                    |
| 출력 결과     | 예: 합계: 15, 평균: 3.0                   |


### 📘 핵심 코드 요약
```kotlin
val numbers = mutableListOf<Int>()
println("n개의 정수를 입력하세요 (종료 0)")
while (true) {
    val input = readln().toInt()
    if (input == 0) break
    numbers.add(input)
}
val sum = numbers.sum()
val average = sum.toDouble() / numbers.size
println("입력한 정수의 합계: $sum")
println("입력한 정수의 평균: $average")
```


## 🛒 문제와 풀이 2: 리스트 기반 쇼핑카트
## ✅ Item 클래스 구성

| 필드 / 메서드       | 설명                                |
|---------------------|-------------------------------------|
| `name`              | 상품명 (예: "마늘", "상추")          |
| `price`             | 단가 (예: 2000원)                    |
| `quantity`          | 수량 (예: 2개, 4개 등)               |
| `getTotalPrice()`   | `price × quantity`로 총합 계산       |

### 📘 Kotlin 클래스 예시
```kotlin
data class Item(val name: String, val price: Int, val quantity: Int) {
    fun getTotalPrice(): Int = price * quantity
}
``` 

## ✅ ShoppingCart 클래스 구성 (Kotlin 버전)

| 구성 요소         | 설명                                                              |
|------------------|-------------------------------------------------------------------|
| `items`          | 장바구니에 담긴 상품들을 저장하는 리스트 (`MutableList<Item>`)     |
| `addItem()`      | 장바구니에 상품을 추가하는 메서드                                  |
| `displayItems()` | 상품 목록을 출력하고 전체 가격 합계를 계산하는 메서드              |


### 📘 Kotlin 클래스 예시
```kotlin
class ShoppingCart {
    private val items = mutableListOf<Item>()

    fun addItem(item: Item) {
        items.add(item)
    }

    fun displayItems() {
        println("장바구니 상품 출력")
        items.forEach {
            println("상품명:${it.name}, 합계:${it.getTotalPrice()}")
        }
        println("전체 가격 합:${calculateTotalPrice()}")
    }

    private fun calculateTotalPrice(): Int {
        return items.sumOf { it.getTotalPrice() }
    }
}
```            


## ✅ 배열과 리스트 비교 (Kotlin 기준)

| 항목               | Array<Item>                        | MutableList<Item>                      |
|--------------------|------------------------------------|----------------------------------------|
| 크기 관리 방식     | `itemCount`로 수동 추적            | `size` 프로퍼티로 자동 관리            |
| 초기 크기 설정     | `Array(10)` 등 고정 크기 필요       | 크기 제한 없음, 자동 확장              |
| 요소 추가 방식     | 인덱스 직접 지정 (`items[i] = ...`) | `add()` 메서드 사용                    |
| 요소 제거 방식     | 직접 null 처리 및 인덱스 이동       | `remove()` 또는 `removeAt()` 사용      |
| 반복 처리 방식     | `for (i in 0 until itemCount)`      | `forEach` 또는 `for (item in items)`   |
| 유연성 및 확장성   | 제한적, 크기 초과 시 오류 발생       | 유연함, 필요 시 자동 확장              |


## ✅ 핵심 요약
- Kotlin에서도 리스트는 배열보다 유연하고 확장성이 뛰어남
- ArrayList는 조회와 순차 삽입

---

