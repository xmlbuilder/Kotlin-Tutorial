# 🚗 Kotlin으로 보는 상속
## ✅ 왜 상속이 필요한가?
## 📌 1. 중복 제거
```kotlin
class ElectricCar {
    fun move() {
        println("차를 이동합니다.")
    }

    fun charge() {
        println("충전합니다.")
    }
}

class GasCar {
    fun move() {
        println("차를 이동합니다.")
    }

    fun fillUp() {
        println("기름을 주유합니다.")
    }
}
```

- move() 메서드가 중복됨 → 유지보수 불리
- 공통 기능을 부모 클래스 Car에 정의하면 중복 제거 가능
```kotlin
open class Car {
    fun move() {
        println("차를 이동합니다.")
    }
}
```


## 📌 2. 추상화와 구조화
- Car는 전기차와 가솔린차를 포괄하는 상위 개념
- 상속을 통해 추상적 개념을 코드 구조에 반영 가능

## 📌 3. 다형성 활용 가능
```kotlin
val car1: Car = ElectricCar()
val car2: Car = GasCar()

car1.move() // 전기차 이동
car2.move() // 가솔린차 이동
```

- 부모 타입으로 다양한 자식 객체를 다룰 수 있음 → 유연한 설계

### 🔧 상속 적용 예시
```kotlin
open class Car {
    fun move() {
        println("차를 이동합니다.")
    }
}

class ElectricCar : Car() {
    fun charge() {
        println("충전합니다.")
    }
}

class GasCar : Car() {
    fun fillUp() {
        println("기름을 주유합니다.")
    }
}
```


## 🧠 핵심 요약: Kotlin 상속
| 개념           | 설명                                                               |
|----------------|--------------------------------------------------------------------|
| 중복 제거       | 공통 기능을 부모 클래스에 정의하여 코드 재사용 가능                   |
| 추상화 구조화   | 상위 개념(Car)으로 하위 개념(ElectricCar, GasCar)을 구조화            |
| 다형성 활용     | 부모 타입(Car)으로 다양한 자식 객체를 다룰 수 있어 유연한 설계 가능     |
| 유지보수 용이   | 공통 기능 수정 시 부모 클래스만 수정하면 전체 반영 가능                |
| 현실 모델링     | 실제 세계의 관계를 코드로 자연스럽게 표현 가능                         |


## 📘 Kotlin 상속 문서 정리
### 1. 상속이란?
- 상속은 객체 지향 프로그래밍(OOP)의 핵심 개념 중 하나
- `:` 기호를 사용하여 부모 클래스를 상속받음 (class ElectricCar : Car())

### 📘 2. 용어 정리
| 용어         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| 부모 클래스   | Car 클래스. 자식 클래스에게 기능을 제공하는 상위 클래스                |
| 자식 클래스   | ElectricCar, GasCar 클래스. Car 클래스를 상속받아 기능을 물려받는 클래스 |
| `:` 기호     | 자식 클래스가 부모 클래스를 상속할 때 사용하는 문법 (`class A : B()`)   |


### 3. 코드 구조 예시
#### ✅ 부모 클래스
```kotlin
open class Car {
    fun move() {
        println("차를 이동합니다.")
    }
}
```

#### ✅ 자식 클래스
```kotlin
class ElectricCar : Car() {
    fun charge() {
        println("충전합니다.")
    }
}

class GasCar : Car() {
    fun fillUp() {
        println("기름을 주유합니다.")
    }
}
```

#### ✅ 실행 코드
```kotlin
fun main() {
    val electricCar = ElectricCar()
    electricCar.move()     // 부모 기능
    electricCar.charge()   // 자식 기능

    val gasCar = GasCar()
    gasCar.move()          // 부모 기능
    gasCar.fillUp()        // 자식 기능
}
```


### 4. 실행 결과
```
차를 이동합니다.
충전합니다.
차를 이동합니다.
기름을 주유합니다.
```


### ✅ 5. 상속의 장점
| 항목           | 설명                                                                 |
|----------------|----------------------------------------------------------------------|
| 코드 재사용     | 공통 기능을 부모 클래스에 정의하여 자식 클래스에서 재사용 가능           |
| 구조화          | 상위 개념(Car) → 하위 개념(ElectricCar, GasCar)로 계층적 설계 가능       |
| 유지보수 용이   | 공통 기능 수정 시 부모 클래스만 수정하면 전체 반영 가능                  |
| 다형성 활용     | 부모 타입(Car)으로 다양한 자식 객체를 다룰 수 있어 유연한 설계 가능       |
| 현실 모델링     | 실제 세계의 관계(예: 자동차 → 전기차, 가솔린차)를 코드로 자연스럽게 표현 가능 |


---

# 📘 Kotlin의 단일 상속과 메모리 구조
## 1. 단일 상속이란?
Kotlin도 자바처럼 클래스의 다중 상속을 지원하지 않으며, 하나의 클래스만 상속받을 수 있습니다.  
즉, `:` 기호로 지정할 수 있는 부모 클래스는 오직 하나입니다.  
```kotlin
class ElectricCar : Car() {
    // Car 클래스만 상속 가능
}
```

## 2. 왜 다중 상속을 금지할까?
### ❌ 다중 상속의 문제점
- 다이아몬드 문제 발생 가능  
    예: AirplaneCar가 Airplane과 Car를 동시에 상속받을 경우, move() 호출 시 어떤 부모의 메서드를 사용할지 모호함  
- 클래스 계층 구조가 복잡해짐  
    유지보수 어려움, 충돌 가능성 증가  
#### ➡️ Kotlin도 이러한 문제를 피하기 위해 클래스의 다중 상속을 금지하고, 대신 인터페이스의 다중 구현을 허용합니다.

## 3. 상속과 메모리 구조
```kotlin
val electricCar = ElectricCar()
```

- ElectricCar 객체를 생성하면 내부적으로 부모 클래스인 Car도 함께 초기화됨
- 참조값은 하나 (x001)이지만, 내부에는 Car와 ElectricCar의 정보가 함께 존재함

## 🧠 메모리 구조 요약
| 참조값 | 내부 구성             | 기능 예시                      | 설명                                                                 |
|--------|----------------------|-------------------------------|----------------------------------------------------------------------|
| x001   | ElectricCar, Car     | charge()                      | 자식 클래스의 고유 기능. ElectricCar 내부에서 직접 정의됨             |
| x001   | ElectricCar, Car     | move()                        | 부모 클래스(Car)에서 정의된 공통 기능. 상속을 통해 호출됨             |


## 4. 메서드 호출 흐름
### ✅ electricCar.charge() 호출
- electricCar의 타입은 ElectricCar
- ElectricCar에 charge() 메서드가 있으므로 바로 호출됨
### ✅ electricCar.move() 호출
- ElectricCar에는 move() 없음
- 상속 관계에 따라 부모 클래스인 Car에서 move()를 찾아 호출됨

## 🧠 호출 흐름 요약
| 호출 대상         | 탐색 기준                  | 예시 호출                      | 설명                                                                 |
|------------------|----------------------------|-------------------------------|----------------------------------------------------------------------|
| 자식 클래스에 존재 | 자식 클래스에서 바로 탐색    | electricCar.charge()          | ElectricCar 내부에 정의된 메서드이므로 바로 호출됨                    |
| 자식 클래스에 없음 | 부모 클래스에서 탐색        | electricCar.move()            | ElectricCar에 없으므로 Car로 올라가서 move() 호출됨                  |
| 부모에도 없음      | 상위 부모로 계속 탐색       | —                             | 상속 계층을 따라 위로 올라가며 기능 탐색, 끝까지 없으면 컴파일 오류 발생 |
| 호출 기준         | 참조 변수의 타입 기준 탐색  | val electricCar = ElectricCar() | 참조 변수 타입이 ElectricCar이므로 해당 클래스부터 탐색 시작           |

## ✅ 핵심 요약
| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 단일 상속         | Kotlin은 클래스 상속 시 하나의 부모만 지정 가능 (`:` 사용)             |
| 코드 재사용       | 공통 기능을 부모 클래스에 정의하여 자식 클래스에서 재사용 가능           |
| 구조화            | 상위 개념(Car) → 하위 개념(ElectricCar, GasCar)로 계층적 설계 가능       |
| 메모리 구조 이해   | 객체 생성 시 부모와 자식 클래스가 함께 메모리에 구성됨                   |
| 호출 흐름         | 참조 변수의 타입 기준으로 기능 탐색, 없으면 부모로 올라가며 기능을 찾음   |


---

# 📘 상속을 활용한 기능 추가와 클래스 확장
## 1. 기능 추가의 목적
- 모든 차량에 공통 기능인 openDoor()를 추가해야 하는 상황
- 부모 클래스 Car에 기능을 추가하면 모든 자식 클래스에 자동 적용됨
- 중복 없이 유지보수가 쉬운 구조로 확장 가능

## 2. 코드 구조 요약
### ✅ 부모 클래스
```kotlin
open class Car {
    fun move() {
        println("차를 이동합니다.")
    }

    fun openDoor() {
        println("문을 엽니다.")
    }
}
```

### ✅ 자식 클래스들
```kotlin
class ElectricCar : Car() {
    fun charge() {
        println("충전합니다.")
    }
}

class GasCar : Car() {
    fun fillUp() {
        println("기름을 주유합니다.")
    }
}

class HydrogenCar : Car() {
    fun fillHydrogen() {
        println("수소를 충전합니다.")
    }
}
```


## 3. 실행 흐름
```kotlin
fun main() {
    val electricCar = ElectricCar()
    electricCar.move()
    electricCar.charge()
    electricCar.openDoor()

    val gasCar = GasCar()
    gasCar.move()
    gasCar.fillUp()
    gasCar.openDoor()

    val hydrogenCar = HydrogenCar()
    hydrogenCar.move()
    hydrogenCar.fillHydrogen()
    hydrogenCar.openDoor()
}
```


## 4. 실행 결과
```
차를 이동합니다.
충전합니다.
문을 엽니다.
차를 이동합니다.
기름을 주유합니다.
문을 엽니다.
차를 이동합니다.
수소를 충전합니다.
문을 엽니다.
```


## ✅ 핵심 요약
| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 공통 기능 상속     | move(), openDoor()는 Car에서 정의되어 모든 자식 클래스에서 사용 가능     |
| 자식 고유 기능     | 각 자식 클래스는 charge(), fillUp(), fillHydrogen() 등 고유 기능을 가짐  |
| 코드 중복 제거     | 공통 기능은 부모 클래스에 한 번만 정의하여 중복 없이 재사용 가능          |
| 확장성 용이       | 새로운 차량(HydrogenCar 등)도 쉽게 추가 가능                             |
| 유지보수 편리함    | 공통 기능 수정 시 부모 클래스만 수정하면 전체 자식 클래스에 반영됨         |

---

# 📘 상속과 메서드 오버라이딩 정리
## 1. 오버라이딩이란?
- 부모 클래스의 메서드를 자식 클래스에서 같은 이름, 시그니처로 재정의하는 것
- 상속 관계에서만 사용 가능

## 2. 오버라이딩 예시
```kotlin
open class Car {
    open fun move() {
        println("차를 이동합니다.")
    }
}

class ElectricCar : Car() {
    override fun move() {
        println("전기차를 빠르게 이동합니다.")
    }
}

fun main() {
    val electricCar = ElectricCar()
    electricCar.move() // "전기차를 빠르게 이동합니다." 출력
}
```


## 3. override 키워드
- Kotlin에서는 오버라이딩 시 override 키워드 필수
- 부모 클래스의 메서드가 open이어야 오버라이딩 가능
- 실수 방지 및 코드 명확성 향상

## 🧠 오버라이딩과 메모리 구조
| 단계             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 객체 생성         | ElectricCar 객체 생성 시 내부에 Car와 ElectricCar 정보가 함께 생성됨     |
| 참조값 탐색 시작  | electricCar.move() 호출 시 참조값(x001)을 따라 ElectricCar부터 탐색 시작 |
| 메서드 탐색       | ElectricCar에 move()가 오버라이딩되어 있으므로 해당 메서드를 실행함       |
| 부모 탐색 생략    | 자식 클래스에서 메서드를 찾았으므로 Car로 올라가지 않음                   |

## 🔄 오버로딩 vs 오버라이딩
| 항목             | 오버로딩 (Overloading)                                      | 오버라이딩 (Overriding)                                      |
|------------------|-------------------------------------------------------------|--------------------------------------------------------------|
| 정의             | 같은 이름의 메서드를 **매개변수만 다르게** 여러 개 정의         | 부모 클래스의 메서드를 자식 클래스에서 **재정의**              |
| 관계             | **같은 클래스 내** 에서 사용                                   | **상속 관계** 에서 사용                                        |
| 매개변수         | **타입, 개수, 순서가 다름**                                   | **부모와 완전히 동일해야 함**                                 |
| 반환 타입        | 달라도 됨                                                    | 같거나 **하위 타입** 만 가능                                   |
| 접근 제어자      | 자유롭게 설정 가능                                           | 부모보다 **더 제한적이면 안 됨**                              |
| 키워드           | 사용하지 않음                                                | `override` 키워드 사용 필요                                   |
| 목적             | 다양한 입력에 대해 같은 이름의 기능 제공                       | 부모의 기능을 자식이 새롭게 정의하여 동작 변경                 |
| 예시             | `fun print(x: Int)`, `fun print(x: String)`                 | `open fun move()` → `override fun move()`                    |


## ✅ 메서드 오버라이딩 조건
| 조건 항목         | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| 메서드 이름        | 부모 클래스의 메서드와 **이름이 같아야 함**                           |
| 매개변수           | **타입, 개수, 순서가 모두 동일** 해야 함                               |
| 반환 타입          | 부모와 같거나 **하위 타입** 일 수 있음                                 |
| 접근 제어자        | 부모보다 **더 제한적이면 안 됨** (`public` → `private` 불가)          |
| 예외 처리          | 부모보다 **더 많은 체크 예외 throws 불가**, 하위 예외는 허용           |
| 불가능한 키워드    | `final`, `private`, `companion object` → 오버라이딩 불가                         |
| 키워드 사용        | Kotlin에서는 반드시 `override` 키워드 사용                             |

---
